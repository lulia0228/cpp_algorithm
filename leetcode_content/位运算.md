<!-- GFM-TOC -->
* [1. 只出现一次的数字](#1-只出现一次的数字)
* [2. 只出现一次的数字II](#2-只出现一次的数字II)
* [3. 只出现一次的数字III](#3-只出现一次的数字III)
* [4. 颠倒二进制位](#4-颠倒二进制位)
* [5. 2的幂](#5-2的幂)
* [6. 找出数组中缺失的那个数](#6-找出数组中缺失的那个数)
* [7. 位1的个数](#7-位1的个数)
* [8. 统计从0~n每个数的二进制表示中 1 的个数](#8-统计从0-n每个数的二进制表示中1的个数)
* [9. 两整数之和](#9-两整数之和)
* [10. 汉明距离](#10-汉明距离)
* [11. 求一个数的补码](#11-求一个数的补码)
* [12. 判断一个数的位级表示是否不会出现连续的0和1](#12-判断一个数的位级表示是否不会出现连续的0和1)
<!-- GFM-TOC -->

位运算技巧点：
```
1)	使用 x & 1 == 1 判断奇偶数。
2)	不使用第三个数，交换两个数。x = x ^ y ， y = x ^ y ， x = x ^ y。
3)	两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身。（对于找数这块，异或往往有一些别样的用处。）
4)	x & (x-1), 可以将最右边的 1 设置为 0。（这个技巧可以用来检测 2的幂，或者检测一个整数二进制中 1 的个数，
    又或者别人问你一个数变成另一个数其中改变了多少个bit位，统统都是它）
5)  n |=（n+1）可以将最低位的0去掉.可用于判断二进制中0的个数，直到全部都是位都是1 表示-1 加1 即为0
5)	异或可以被当做无进位加法使用，与操作可以用来获取进位。
6)	i+(~i)=-1，i 取反再与 i 相加，相当于把所有二进制位设为1，其十进制结果为-1。
7)	对于int32而言，使用 n >> 31取得 n 的正负号。并且可以通过 (n ^ (n >> 31)) - (n >> 31) 来得到绝对值。（n为正，n >> 31 的所有位等于0。若n为负数，n >> 31 的所有位等于1，其值等于-1）
8)  左移一位相当于乘以2；右移一位相当于除以2.  无符号右移：右移正数时高位补0、右移负数时则高位补1。
```

## 1 只出现一次的数字
136\. Single Number

[力扣](https://leetcode-cn.com/problems/single-number/) / [Leetcode](https://leetcode.com/problems/single-number/) / [Cpp](../ds_9_bit_operation/L136.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L136.py)
```
题目：无序、非空整数数组，除了一个元素出现1次，其余均出现2次，使用O(n)时间复杂度、不使用额外空间找到这个元素。
```
## 2 只出现一次的数字II
137\. Single Number II

[力扣](https://leetcode-cn.com/problems/single-number-ii/) / [Leetcode](https://leetcode.com/problems/single-number-ii/) / [Cpp](../ds_9_bit_operation/L137-m.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L137-m.py)
```
题目：无序、非空整数数组，除了一个元素出现1次，其余均出现3次，使用O(n)时间复杂度、不使用额外空间找到这个元素。
```

## 3 只出现一次的数字III
260\. Single Number III

[力扣](https://leetcode-cn.com/problems/single-number-iii/) / [Leetcode](https://leetcode.com/problems/single-number-iii/) / [Cpp](../ds_9_bit_operation/L260-m.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L260-m.py)
```
题目：无序、非空整数数组，除了2个元素出现1次，其余均出现2次，使用O(n)时间复杂度、不使用额外空间找到这两个元素。
```

## 4 颠倒二进制位
190\. Reverse Bits

[力扣](https://leetcode-cn.com/problems/reverse-bits/) / [Leetcode](https://leetcode.com/problems/reverse-bits/) / [Cpp](../ds_9_bit_operation/L190.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L190.py)
```
题目：颠倒给定的 32 位无符号整数的二进制位。
```



## 5 2的幂
231\. Power of Two 

[力扣](https://leetcode-cn.com/problems/power-of-two/) / [Leetcode](https://leetcode.com/problems/power-of-two/) / [Cpp](../ds_9_bit_operation/L231.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L231.py)
```
题目：给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
```

## 6 找出数组中缺失的那个数
268\. Missing Number	 

[力扣](https://leetcode-cn.com/problems/missing-number/) / [Leetcode](https://leetcode.com/problems/missing-number/) / [Cpp](../ds_7_array_inplace/L268.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L268.py)
```
题目：给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。
```

## 7 位1的个数
191\. Number of 1 Bits

[力扣](https://leetcode-cn.com/problems/number-of-1-bits/) / [Leetcode](https://leetcode.com/problems/number-of-1-bits/) / [Cpp](../ds_9_bit_operation/L191.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L191.py)
```
题目：汉明重量-给定一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数
```

## 8 统计从0-n每个数的二进制表示中1的个数 
338\. Counting Bits

[力扣](https://leetcode-cn.com/problems/counting-bits/) / [Leetcode](https://leetcode.com/problems/counting-bits/) / [Cpp](../algo_05_dynamic_plan/L338-m.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L338-m.py)
```
题目：给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
```

## 9 两整数之和
371\. Sum of Two Integers	

[力扣](https://leetcode-cn.com/problems/sum-of-two-integers/) / [Leetcode](https://leetcode.com/problems/sum-of-two-integers/) / [Cpp](../ds_9_bit_operation/L371-m.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L371-m.py)
```
题目：不使用运算符 + 和 - ，计算两整数 a 、b 之和。
```

## 10 汉明距离
461\. Hamming Distance

[力扣](https://leetcode-cn.com/problems/hamming-distance/) / [Leetcode](https://leetcode.com/problems/hamming-distance/) / [Cpp](../ds_9_bit_operation/L461.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L461.py)
```
题目:两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
```

## 11 求一个数的补码
476\. Number Complement

[力扣](https://leetcode-cn.com/problems/number-complement/) / [Leetcode](https://leetcode.com/problems/number-complement/) / [Cpp](../ds_9_bit_operation/L476.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L476.py)
```
题目：给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。
```

## 12 判断一个数的位级表示是否不会出现连续的0和1
693\. Binary Number with Alternating Bits

[力扣](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/) / [Leetcode](https://leetcode.com/problems/binary-number-with-alternating-bits/) / [Cpp](../ds_9_bit_operation/L693.cpp) / [Python3](../python-algorithm/ds_9_bit_operation/L693.py)
```
题目：给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。
```

