<!-- GFM-TOC -->
* [典型问题](#典型问题)
    * [1. 用栈实现括号匹配](#1-用栈实现括号匹配)
    * [2. Linux简化路径](#2-Linux简化路径)
    * [3. 逆波兰表达式](#3-逆波兰表达式)
    * [4. 最小值栈](#4-最小值栈)
    * [5. 字符串解码](#5-字符串解码)
    * [6. 反转字符串中的单词](#6-反转字符串中的单词)
    
* [栈和队列](#栈和队列)
    * [1. 用栈实现队列](#1-用栈实现队列)
    * [2. 用队列实现栈](#2-用队列实现栈)
    * [3. 栈排序](#3-栈排序)
    * [4. 栈和排序](#4-栈和排序)
    
* [单调栈](#单调栈)
    * [1. 柱状图中的最大矩形](#1-柱状图中的最大矩形)
    * [2. 数组中元素与下一个比它大的元素之间的距离](#2-数组中元素与下一个比它大的元素之间的距离)
    * [3. 循环数组中比当前元素大的下一个元素](#3-循环数组中比当前元素大的下一个元素)
    * [4. 数组中每个位置左右两边最近的小值](#4-数组中每个位置左右两边最近的小值)
    
<!-- GFM-TOC -->

# 典型问题 
## 1 用栈实现括号匹配
20\. Valid Parentheses (Easy)  

[力扣](https://leetcode-cn.com/problems/valid-parentheses/) / [Leetcode](https://leetcode.com/problems/valid-parentheses/) / [Cpp](../ds_1_stack_queue/L20.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L20.py)

## 2 Linux简化路径
71\. 简化路径

[力扣](https://leetcode-cn.com/problems/simplify-path/) / [Leetcode](https://leetcode.com/problems/simplify-path/) / [Cpp](../ds_1_stack_queue/L71-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L71-m.py)

## 3 逆波兰表达式
150\. 逆波兰表达式

[力扣](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) / [Leetcode](https://leetcode.com/problems/evaluate-reverse-polish-notation/) / [Cpp](../ds_1_stack_queue/L150-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L150-m.py)
```
题目:根据逆波兰表示法，求表达式的值。
说明：
    整数除法只保留整数部分。
    给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
    有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
示例：
   输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
   输出: 22
   解释: 
         该算式转化为常见的中缀算术表达式为：
           ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
         = ((10 * (6 / (12 * -11))) + 17) + 5
         = ((10 * (6 / -132)) + 17) + 5
         = ((10 * 0) + 17) + 5
         = (0 + 17) + 5
         = 17 + 5
         = 22
```

## 4 最小值栈
155\. 常数时间复杂度获取栈中的最小元素

[力扣](https://leetcode-cn.com/problems/min-stack/) / [Leetcode](https://leetcode.com/problems/min-stack/) / [Cpp](../ds_1_stack_queue/L155.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L155.py)
```
题目:设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
     pop、top 和 getMin 操作总是在 非空栈 上调用。
   push(x) —— 将元素 x 推入栈中。
   pop() —— 删除栈顶的元素。
   top() —— 获取栈顶元素。
   getMin() —— 检索栈中的最小元素。
```

## 5 字符串解码
394\. 字符串解码

[力扣](https://leetcode-cn.com/problems/decode-string/) / [Leetcode](https://leetcode.com/problems/decode-string/) / [Cpp](../ds_1_stack_queue/L394-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L394-m.py)
```
题目:给定一个经过编码的字符串，返回它解码后的字符串。
说明:你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
     此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。
示例 1：
      输入：s = "3[a]2[bc]"
      输出："aaabcbc"

示例 2：
      输入：s = "3[a2[c]]"
      输出："accaccacc"

示例 3：
      输入：s = "2[abc]3[cd]ef"
      输出："abcabccdcdcdef"

示例 4：
      输入：s = "abc3[cd]xyz"
      输出："abccdcdcdxyz"
```

## 6 反转字符串中的单词
557\. 反转字符串中的单词 III

[力扣](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/) / [Leetcode](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/) / [Cpp](../ds_1_stack_queue/L557.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L557.py)
```
题目:给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
    在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
示例：
      输入："Let's take LeetCode contest"
      输出："s'teL ekat edoCteeL tsetnoc"
```

# 栈和队列
## 1 用栈实现队列   
232\. 用栈实现队列  

[力扣](https://leetcode-cn.com/problems/implement-queue-using-stacks/) / [Leetcode](https://leetcode.com/problems/implement-queue-using-stacks/) / [Cpp](../ds_1_stack_queue/L232.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L232.py)

思路：使用2个栈，两次反转恢复原来顺序，值得注意的是只有当第二个栈为空的时候，才将第一个栈中的所有元素压入第二个栈中。
```
题目:使用栈实现队列的下列操作：
   push(x) -- 将一个元素放入队列的尾部。
   pop() -- 从队列首部移除元素。
   peek() -- 返回队列首部的元素。
   empty() -- 返回队列是否为空。
```

## 2 用队列实现栈
225\. 用队列实现栈

[力扣](https://leetcode-cn.com/problems/implement-stack-using-queues/) / [Leetcode](https://leetcode.com/problems/implement-stack-using-queues/) / [Cpp](../ds_1_stack_queue/L225.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L225.py)
```
题目:使用队列实现栈的下列操作：
   push(x) -- 元素 x 入栈
   pop() -- 移除栈顶元素
   top() -- 获取栈顶元素
   empty() -- 返回栈是否为空

两个队列交换实现倒排：
    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        # 新元素从que2进，通过交换使得每次输入新的元素后
        # 所有元素在que1中按照顺序倒排，que2清空
        self.que2.append(x)
        while self.que1 != []:
            self.que2.append(self.que1.pop(0))
        tmp_que = self.que1 # 此时que1已经是空队列
        self.que1 = self.que2
        self.que2 = tmp_que
```

## 3 栈排序  
面试题 03.05. 栈排序 

[力扣](https://leetcode-cn.com/problems/sort-of-stacks-lcci/) / [Python3](../python-algorithm/ds_1_stack_queue/03.05.py)     
```
栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。
该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。

输入：
["SortedStack", "push", "push", "peek", "pop", "peek"]
[[], [1], [2], [], [], []]
输出：
[null,null,null,1,null,2]

```

## 4 栈和排序  
NC115\. 栈和排序 

[牛客](https://www.nowcoder.com/practice/95cb356556cf430f912e7bdf1bc2ec8f?tpId=117&&tqId=37839&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking) / [Python3](../python-algorithm/ds_1_stack_queue/NC115.py)     
```
给你一个1->n的排列和一个栈，入栈顺序给定，你要在不打乱入栈顺序的情况下，对数组进行从大到小排序
当无法完全排序时，请输出字典序最大的出栈序列
输入：
[2,1,5,3,4]
输出：
[5,4,3,1,2]
```

# 单调栈
## 1 柱状图中的最大矩形
84\. 柱状图中最大的矩形

[力扣](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) / [Leetcode](https://leetcode.com/problems/largest-rectangle-in-histogram/) / [Cpp](../ds_1_stack_queue/L84-h.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L84-h.py)
```
题目:给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
    求在该柱状图中，能够勾勒出来的矩形的最大面积。
示例:
   输入: [2,1,5,6,2,3]
   输出: 10
```

## 2 数组中元素与下一个比它大的元素之间的距离
739\. 每日温度

[力扣](https://leetcode-cn.com/problems/daily-temperatures/) / [Leetcode](https://leetcode.com/problems/daily-temperatures/) / [Cpp](../ds_1_stack_queue/L739-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L739-m.py)
```
题目:请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。
如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
```

## 3 循环数组中比当前元素大的下一个元素
503\. 下一个更大元素 II

[力扣](https://leetcode-cn.com/problems/next-greater-element-ii/) / [Leetcode](https://leetcode.com/problems/next-greater-element-ii/) / [Cpp](../ds_1_stack_queue/L503-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L503-m.py)

```
题目:给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x
    的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的
    下一个更大的数。如果不存在，则输出 -1。
示例 1:
      输入: [1,2,1]
      输出: [2,-1,2]
      解释: 第一个 1 的下一个更大的数是 2；
      数字 2 找不到下一个更大的数； 
      第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

## 4 数组中每个位置左右两边最近的小值
NC157\. 数组中每个位置左右两边最近的小值  

[牛客](https://www.nowcoder.com/practice/ae25fb47d34144a08a0f8ff67e8e7fb5?tpId=117&&tqId=37867&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking) / [Python3](../python-algorithm/ds_1_stack_queue/NC157.py)

```
题目:给定一个可能含有重复值的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。
     位置信息包括：两个数字 L 和 R，如果不存在，则值为 -1，下标从 0 开始。
示例 1:
      输入: [3,4,1,5,6,2,7]
      输出: [[-1,2],[0,2],[-1,-1],[2,5],[3,5],[2,-1],[5,-1]]  
```
