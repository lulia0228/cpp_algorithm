<!-- GFM-TOC -->
* [典型问题](#典型问题)
    * [1. 用栈实现括号匹配](#1-用栈实现括号匹配)
    * [2. Linux简化路径](#2-Linux简化路径)
    * [3. 逆波兰表达式](#3-逆波兰表达式)
    * [4. 最小值栈](#4-最小值栈)
    * [5. 字符串解码](#5-字符串解码)
    * [6. 反转字符串中的单词](#6-反转字符串中的单词)
    
* [栈和队列](#栈和队列)
    * [1. 用栈实现队列](#1-用栈实现队列)
    * [2. 用队列实现栈](#2-用队列实现栈)
    
* [单调栈](#单调栈)
    * [1. 柱状图中的最大矩形](#1-柱状图中的最大矩形)
    * [2. 数组中元素与下一个比它大的元素之间的距离](#2-数组中元素与下一个比它大的元素之间的距离)
    * [3. 循环数组中比当前元素大的下一个元素](#3-循环数组中比当前元素大的下一个元素)
    
<!-- GFM-TOC -->

# 典型问题 <font color=red> </font>
## 1 用栈实现括号匹配
20\. Valid Parentheses (Easy)  

[力扣](https://leetcode-cn.com/problems/valid-parentheses/) / [Leetcode](https://leetcode.com/problems/valid-parentheses/) / [SRC](../ds_1_stack_queue/L20.cpp)

思路：使用2个栈，两次反转恢复原来顺序，值得注意的是只有当第二个栈为空的时候，才将第一个栈中的所有元素压入第二个栈中。

```cpp
 bool isValid(string s) {
     stack<char> stk1;
     for(int i=0 ;i<s.size();i++){
         if(s[i]=='('||s[i]=='['||s[i]=='{')
             stk1.push(s[i]);
         else{
             char tem_char ;
             if(s[i] == ')')
                 tem_char = '(';
             else if(s[i] == ']')
                 tem_char = '[';
             else
                 tem_char = '{';
             if(stk1.empty() || stk1.top() != tem_char) //注意一定要判定栈为空(为空代表没有匹配值)；此外栈为空时候取栈顶元素会报错
                 return false;
             stk1.pop();
         }
     }
     if(!stk1.empty()) //意味着栈中还有值，字符串不合法
         return false;
     return true;
 }
```

      
## 2 Linux简化路径

## 3 逆波兰表达式

## 4 最小值栈

## 5 字符串解码

## 6 反转字符串中的单词

# 栈和队列
## 1 用栈实现队列

## 2 用队列实现栈

# 单调栈
## 1 柱状图中的最大矩形

## 2 数组中元素与下一个比它大的元素之间的距离

## 3 循环数组中比当前元素大的下一个元素
