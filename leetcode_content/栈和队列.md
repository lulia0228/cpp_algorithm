<!-- GFM-TOC -->
* [典型问题](#典型问题)
    * [1. 用栈实现括号匹配](#1-用栈实现括号匹配)
    * [2. 反转字符串中的单词](#2-反转字符串中的单词)
    * [3. 反转字符串中的单词3](#3-反转字符串中的单词3)
    * [4. 最小值栈](#4-最小值栈)
    * [5. 字符串解码](#5-字符串解码)
    * [6. 删除字符串中的所有相邻重复项](#6-删除字符串中的所有相邻重复项)
    * [7. 删除字符串中的所有相邻重复项2](#7-删除字符串中的所有相邻重复项2)
    * [8. 栈排序](#8-栈排序)
    * [9. 栈和排序](#9-栈和排序)
    * [10. Linux简化路径](#10-Linux简化路径)
    * [11. 栈的压入弹出序列](#11-栈的压入弹出序列)
    * [12. 逆波兰表达式](#12-逆波兰表达式)

    
* [单调栈](#单调栈)
    * [1. 柱状图中的最大矩形](#1-柱状图中的最大矩形)
    * [2. 数组中元素与下一个比它大的元素之间的距离](#2-数组中元素与下一个比它大的元素之间的距离)
    * [3. 循环数组中比当前元素大的下一个元素](#3-循环数组中比当前元素大的下一个元素)
    * [4. 数组中每个位置左右两边最近的小值](#4-数组中每个位置左右两边最近的小值)
   
* [队列](#队列)
    * [1. 滑动窗口的最大值](#1-滑动窗口的最大值)
    * [2. 队列的最大值](#1-队列的最大值)
    * [3. 绝对差不超过限制的最长连续子数组](#3-绝对差不超过限制的最长连续子数组)

* [栈和队列](#栈和队列)
    * [1. 用栈实现队列](#1-用栈实现队列)
    * [2. 用队列实现栈](#2-用队列实现栈)
    
<!-- GFM-TOC -->

# 典型问题 
## 1 用栈实现括号匹配
20\. Valid Parentheses (Easy)  

[力扣](https://leetcode-cn.com/problems/valid-parentheses/) / [Leetcode](https://leetcode.com/problems/valid-parentheses/) / [Cpp](../ds_1_stack_queue/L20.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L20.py)

## 2 反转字符串中的单词
151\. 反转字符串中的单词

[力扣](https://leetcode-cn.com/problems/reverse-words-in-a-string/) / [Leetcode](https://leetcode.com/problems/reverse-words-in-a-string/) / [Cpp](../ds_1_stack_queue/L151.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L151-m.py)
```
题目:给你一个字符串 s ，逐个翻转字符串中的所有 单词 。
    单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
    请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。
说明:输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
    翻转后单词间应当仅用一个空格分隔。
    翻转后的字符串中不应包含额外的空格。
示例：
      输入：s = "  hello   world  "
      输出："world hello"
```

## 3 反转字符串中的单词3
557\. 反转字符串中的单词 III

[力扣](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/) / [Leetcode](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/) / [Cpp](../ds_1_stack_queue/L557.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L557.py)
```
题目:给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
    在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
示例：
      输入："Let's take LeetCode contest"
      输出："s'teL ekat edoCteeL tsetnoc"
```


## 4 最小值栈
155\. 常数时间复杂度获取栈中的最小元素

[力扣](https://leetcode-cn.com/problems/min-stack/) / [Leetcode](https://leetcode.com/problems/min-stack/) / [Cpp](../ds_1_stack_queue/L155.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L155.py)
```
题目:设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
     pop、top 和 getMin 操作总是在 非空栈 上调用。
   push(x) —— 将元素 x 推入栈中。
   pop() —— 删除栈顶的元素。
   top() —— 获取栈顶元素。
   getMin() —— 检索栈中的最小元素。
```

## 5 字符串解码
394\. 字符串解码

[力扣](https://leetcode-cn.com/problems/decode-string/) / [Leetcode](https://leetcode.com/problems/decode-string/) / [Cpp](../ds_1_stack_queue/L394-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L394-m.py)
```
题目:给定一个经过编码的字符串，返回它解码后的字符串。
说明:你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
     此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。
示例 1：
      输入：s = "3[a]2[bc]"
      输出："aaabcbc"

示例 2：
      输入：s = "3[a2[c]]"
      输出："accaccacc"

示例 3：
      输入：s = "2[abc]3[cd]ef"
      输出："abcabccdcdcdef"

示例 4：
      输入：s = "abc3[cd]xyz"
      输出："abccdcdcdxyz"
```

## 6 删除字符串中的所有相邻重复项
1047\. 删除字符串中的所有相邻重复项

[力扣](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/) / [Leetcode](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/) / [Cpp](../ds_1_stack_queue/L1047.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L1047.py)
```
题目:给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
     在 S 上反复执行重复项删除操作，直到无法继续删除。
     在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
输入："abbaca"
输出："ca"
解释：例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。
      之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

## 7 删除字符串中的所有相邻重复项2
1209\. 删除字符串中的所有相邻重复项2

[力扣](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string-ii/) / [Leetcode](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/) / [Cpp](../ds_1_stack_queue/L1209-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L1209-m.py)
```
题目:给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，
     使被删去的字符串的左侧和右侧连在一起。你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。
     在执行完所有删除操作后，返回最终得到的字符串。本题答案保证唯一。
输入：s = "deeedbbcccbdaa", k = 3
输出："aa"
解释： 
      先删除 "eee" 和 "ccc"，得到 "ddbbbdaa"
      再删除 "bbb"，得到 "dddaa"
      最后删除 "ddd"，得到 "aa"
```

## 8 栈排序  
面试题 03.05. 栈排序 

[力扣](https://leetcode-cn.com/problems/sort-of-stacks-lcci/) / [Python3](../python-algorithm/ds_1_stack_queue/03.05.py)     
```
栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。
该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。

输入：
["SortedStack", "push", "push", "peek", "pop", "peek"]
[[], [1], [2], [], [], []]
输出：
[null,null,null,1,null,2]

```

## 9 栈和排序  
NC115\. 栈和排序 

[牛客](https://www.nowcoder.com/practice/95cb356556cf430f912e7bdf1bc2ec8f?tpId=117&&tqId=37839&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking) / [Python3](../python-algorithm/ds_1_stack_queue/NC115.py)     
```
给你一个1->n的排列和一个栈，入栈顺序给定，你要在不打乱入栈顺序的情况下，对数组进行从大到小排序
当无法完全排序时，请输出字典序最大的出栈序列
输入：
[2,1,5,3,4]
输出：
[5,4,3,1,2]
```

    
## 10 Linux简化路径
71\. 简化路径

[力扣](https://leetcode-cn.com/problems/simplify-path/) / [Leetcode](https://leetcode.com/problems/simplify-path/) / [Cpp](../ds_1_stack_queue/L71-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L71-m.py)

## 11 栈的压入弹出序列    
剑指 Offer 31  

[力扣](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/) / [Python3](./python-algorithm/sword_point_offer/J31.py)  
```
题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。
例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，
但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

## 12 逆波兰表达式
150\. 逆波兰表达式

[力扣](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) / [Leetcode](https://leetcode.com/problems/evaluate-reverse-polish-notation/) / [Cpp](../ds_1_stack_queue/L150-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L150-m.py)
```
题目:根据逆波兰表示法，求表达式的值。
说明：
    整数除法只保留整数部分。
    给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
    有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
示例：
   输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
   输出: 22
   解释: 
         该算式转化为常见的中缀算术表达式为：
           ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
         = ((10 * (6 / (12 * -11))) + 17) + 5
         = ((10 * (6 / -132)) + 17) + 5
         = ((10 * 0) + 17) + 5
         = (0 + 17) + 5
         = 17 + 5
         = 22
```


# 单调栈
## 1 柱状图中的最大矩形
84\. 柱状图中最大的矩形

[力扣](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) / [Leetcode](https://leetcode.com/problems/largest-rectangle-in-histogram/) / [Cpp](../ds_1_stack_queue/L84-h.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L84-h.py)
```
题目:给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
    求在该柱状图中，能够勾勒出来的矩形的最大面积。
示例:
   输入: [2,1,5,6,2,3]
   输出: 10
```

## 2 数组中元素与下一个比它大的元素之间的距离
739\. 每日温度

[力扣](https://leetcode-cn.com/problems/daily-temperatures/) / [Leetcode](https://leetcode.com/problems/daily-temperatures/) / [Cpp](../ds_1_stack_queue/L739-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L739-m.py)
```
题目:请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。
如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
```

## 3 循环数组中比当前元素大的下一个元素
503\. 下一个更大元素 II

[力扣](https://leetcode-cn.com/problems/next-greater-element-ii/) / [Leetcode](https://leetcode.com/problems/next-greater-element-ii/) / [Cpp](../ds_1_stack_queue/L503-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L503-m.py)

```
题目:给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x
    的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的
    下一个更大的数。如果不存在，则输出 -1。
示例 1:
      输入: [1,2,1]
      输出: [2,-1,2]
      解释: 第一个 1 的下一个更大的数是 2；
      数字 2 找不到下一个更大的数； 
      第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

## 4 数组中每个位置左右两边最近的小值
NC157\. 数组中每个位置左右两边最近的小值  

[牛客](https://www.nowcoder.com/practice/ae25fb47d34144a08a0f8ff67e8e7fb5?tpId=117&&tqId=37867&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking) / [Python3](../python-algorithm/ds_1_stack_queue/NC157.py)

```
题目:给定一个可能含有重复值的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。
     位置信息包括：两个数字 L 和 R，如果不存在，则值为 -1，下标从 0 开始。
示例 1:
      输入: [3,4,1,5,6,2,7]
      输出: [[-1,2],[0,2],[-1,-1],[2,5],[3,5],[2,-1],[5,-1]]  
```

# 队列
## 1 滑动窗口的最大值   
NC82\. 滑动窗口的最大值    

[牛客](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=117&&tqId=37784&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking) / [Python3](../python-algorithm/ds_1_stack_queue/NC82.py)

```
题目:给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
示例
输入：[2,3,4,2,6,2,5,1],3
返回值：[4,4,6,6,6,5]
```
## 2 队列的最大值    
剑指 Offer 59-2  

[力扣](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/) / [Python3](./python-algorithm/sword_point_offer/J59_2.py)    
```
题目：请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
```

## 3 绝对差不超过限制的最长连续子数组    
1438\.  绝对差不超过限制的最长连续子数组

[力扣](https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/) / [Leetcode](https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/) / [Cpp](../ds_1_stack_queue/L1438-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L1438-m.py)
```
题目：给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，
     该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。
     如果不存在满足条件的子数组，则返回 0 。
输入：nums = [10,1,2,4,7,2], limit = 5
输出：4 
解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 <= 5 。
```


# 栈和队列
## 1 用栈实现队列   
232\. 用栈实现队列  

[力扣](https://leetcode-cn.com/problems/implement-queue-using-stacks/) / [Leetcode](https://leetcode.com/problems/implement-queue-using-stacks/) / [Cpp](../ds_1_stack_queue/L232.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L232.py)

思路：使用2个栈，两次反转恢复原来顺序，值得注意的是只有当第二个栈为空的时候，才将第一个栈中的所有元素压入第二个栈中。
```
题目:使用栈实现队列的下列操作：
   push(x) -- 将一个元素放入队列的尾部。
   pop() -- 从队列首部移除元素。
   peek() -- 返回队列首部的元素。
   empty() -- 返回队列是否为空。
```

## 2 用队列实现栈
225\. 用队列实现栈

[力扣](https://leetcode-cn.com/problems/implement-stack-using-queues/) / [Leetcode](https://leetcode.com/problems/implement-stack-using-queues/) / [Cpp](../ds_1_stack_queue/L225.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L225.py)
```
题目:使用队列实现栈的下列操作：
   push(x) -- 元素 x 入栈
   pop() -- 移除栈顶元素
   top() -- 获取栈顶元素
   empty() -- 返回栈是否为空

两个队列交换实现倒排：
    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        # 新元素从que2进，通过交换使得每次输入新的元素后
        # 所有元素在que1中按照顺序倒排，que2清空
        self.que2.append(x)
        while self.que1 != []:
            self.que2.append(self.que1.pop(0))
        tmp_que = self.que1 # 此时que1已经是空队列
        self.que1 = self.que2
        self.que2 = tmp_que
```
