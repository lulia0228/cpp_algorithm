<!-- GFM-TOC -->
* [典型问题](#典型问题)
    * [1. 用栈实现括号匹配](#1-用栈实现括号匹配)
    * [2. Linux简化路径](#2-Linux简化路径)
    * [3. 逆波兰表达式](#3-逆波兰表达式)
    * [4. 最小值栈](#4-最小值栈)
    * [5. 字符串解码](#5-字符串解码)
    * [6. 反转字符串中的单词](#6-反转字符串中的单词)
    
* [栈和队列](#栈和队列)
    * [1. 用栈实现队列](#1-用栈实现队列)
    * [2. 用队列实现栈](#2-用队列实现栈)
    
* [单调栈](#单调栈)
    * [1. 柱状图中的最大矩形](#1-柱状图中的最大矩形)
    * [2. 数组中元素与下一个比它大的元素之间的距离](#2-数组中元素与下一个比它大的元素之间的距离)
    * [3. 循环数组中比当前元素大的下一个元素](#3-循环数组中比当前元素大的下一个元素)
    
<!-- GFM-TOC -->

# 典型问题 
## 1 用栈实现括号匹配
20\. Valid Parentheses (Easy)  

[力扣](https://leetcode-cn.com/problems/valid-parentheses/) / [Leetcode](https://leetcode.com/problems/valid-parentheses/) / [Cpp](../ds_1_stack_queue/L20.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L20.py)

## 2 Linux简化路径
71\. 简化路径

[力扣](https://leetcode-cn.com/problems/simplify-path/) / [Leetcode](https://leetcode.com/problems/simplify-path/) / [Cpp](../ds_1_stack_queue/L71-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L71-m.py)

## 3 逆波兰表达式
150\. 逆波兰表达式

[力扣](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) / [Leetcode](https://leetcode.com/problems/evaluate-reverse-polish-notation/) / [Cpp](../ds_1_stack_queue/L150-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L150-m.py)
```
题目:根据逆波兰表示法，求表达式的值。
    有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
示例：
   输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
   输出: 22
   解释: 
         该算式转化为常见的中缀算术表达式为：
           ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
         = ((10 * (6 / (12 * -11))) + 17) + 5
         = ((10 * (6 / -132)) + 17) + 5
         = ((10 * 0) + 17) + 5
         = (0 + 17) + 5
         = 17 + 5
         = 22
```

## 4 最小值栈
155\. 常数时间复杂度获取栈中的最小元素

[力扣](https://leetcode-cn.com/problems/min-stack/) / [Leetcode](https://leetcode.com/problems/min-stack/) / [Cpp](../ds_1_stack_queue/L155.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L155.py)
```
题目:设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
   push(x) —— 将元素 x 推入栈中。
   pop() —— 删除栈顶的元素。
   top() —— 获取栈顶元素。
   getMin() —— 检索栈中的最小元素。
```

## 5 字符串解码
394\. 字符串解码

[力扣](https://leetcode-cn.com/problems/decode-string/) / [Leetcode](https://leetcode.com/problems/decode-string/) / [Cpp](../ds_1_stack_queue/L394-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L394-m.py)
```
题目:给定一个经过编码的字符串，返回它解码后的字符串。
示例 1：
      输入：s = "3[a]2[bc]"
      输出："aaabcbc"

示例 2：
      输入：s = "3[a2[c]]"
      输出："accaccacc"

示例 3：
      输入：s = "2[abc]3[cd]ef"
      输出："abcabccdcdcdef"

示例 4：
      输入：s = "abc3[cd]xyz"
      输出："abccdcdcdxyz"
```

## 6 反转字符串中的单词
557\. 反转字符串中的单词 III

[力扣](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/) / [Leetcode](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/) / [Cpp](../ds_1_stack_queue/L557.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L557.py)
```
题目:给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
    在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
示例：
      输入："Let's take LeetCode contest"
      输出："s'teL ekat edoCteeL tsetnoc"
```

# 栈和队列
## 1 用栈实现队列   
232\. 用栈实现队列  

[力扣](https://leetcode-cn.com/problems/implement-queue-using-stacks/) / [Leetcode](https://leetcode.com/problems/implement-queue-using-stacks/) / [Cpp](../ds_1_stack_queue/L232.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L232.py)

思路：使用2个栈，两次反转恢复原来顺序，值得注意的是只有当第二个栈为空的时候，才将第一个栈中的所有元素压入第二个栈中。
```
题目:使用栈实现队列的下列操作：
   push(x) -- 将一个元素放入队列的尾部。
   pop() -- 从队列首部移除元素。
   peek() -- 返回队列首部的元素。
   empty() -- 返回队列是否为空。
```

## 2 用队列实现栈
225\. 用队列实现栈

[力扣](https://leetcode-cn.com/problems/implement-stack-using-queues/) / [Leetcode](https://leetcode.com/problems/implement-stack-using-queues/) / [Cpp](../ds_1_stack_queue/L225.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L225.py)
```
题目:使用队列实现栈的下列操作：
   push(x) -- 元素 x 入栈
   pop() -- 移除栈顶元素
   top() -- 获取栈顶元素
   empty() -- 返回栈是否为空

```

# 单调栈
## 1 柱状图中的最大矩形
84\. 柱状图中最大的矩形

[力扣](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) / [Leetcode](https://leetcode.com/problems/largest-rectangle-in-histogram/) / [Cpp](../ds_1_stack_queue/L84-h.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L84-h.py)
```
题目:给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
    求在该柱状图中，能够勾勒出来的矩形的最大面积。
示例:
   输入: [2,1,5,6,2,3]
   输出: 10
```

## 2 数组中元素与下一个比它大的元素之间的距离
739\. 每日温度

[力扣](https://leetcode-cn.com/problems/daily-temperatures/) / [Leetcode](https://leetcode.com/problems/daily-temperatures/) / [Cpp](../ds_1_stack_queue/L739-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L739-m.py)
```
题目:请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。
如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
```

## 3 循环数组中比当前元素大的下一个元素
503\. 下一个更大元素 II

[力扣](https://leetcode-cn.com/problems/next-greater-element-ii/) / [Leetcode](https://leetcode.com/problems/next-greater-element-ii/) / [Cpp](../ds_1_stack_queue/L503-m.cpp) / [Python3](../python-algorithm/ds_1_stack_queue/L503-m.py)

```
题目:给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x
    的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的
    下一个更大的数。如果不存在，则输出 -1。
示例 1:
      输入: [1,2,1]
      输出: [2,-1,2]
      解释: 第一个 1 的下一个更大的数是 2；
      数字 2 找不到下一个更大的数； 
      第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```
