<!-- GFM-TOC -->
* [1. 简单排序](#1-冒泡/排序/选择排序)
* [2. 快排](#2-快排)
* [3. 归并排序](#3-归并排序)
* [4. 排序链表](#4-排序链表)
* [5. 计算右侧小于当前元素的个数](#5-计算右侧小于当前元素的个数)
* [6. 三色排序](#6-颜色分类)
* [7. 按照字符出现次数对字符串排序](#7-按照字符出现次数对字符串排序)
* [8. 任务调度器](#8-任务调度器)
<!-- GFM-TOC -->

## 1 冒泡/排序/选择排序
[Cpp](../algo_01_sort/sort-algorithms.cpp) / [Python3](../python-algorithm/algo_01_sort/sort-algorithms.py)
```cpp
```

## 2 快排
[Cpp](../algo_01_sort/quick_sort_algorithm.cpp) / [Python3](../python-algorithm/algo_01_sort/quick_sort_algorithm.py)
```cpp
```

## 3 归并排序
[Cpp](../algo_01_sort/merge_sort_algorithm.cpp) / [Python3](../python-algorithm/algo_01_sort/merge_sort_algorithm.py)
```cpp
```

## 4 排序链表  
148\. Sort List

[力扣](https://leetcode-cn.com/problems/sort-list/) / [Leetcode](https://leetcode.com/problems/sort-list/) / [Cpp](../algo_07_divide_and_conquer/L148-m-copy.cpp) / [Python3](../python-algorithm/algo_01_sort/L148-m-copy.py)
```
题目：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。
```
## 5 计算右侧小于当前元素的个数
315\. Count of Smaller Numbers After Self

[力扣](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/) / [Leetcode](https://leetcode.com/problems/count-of-smaller-numbers-after-self/) / [Cpp](../algo_01_sort/L315-h.cpp) / [Python3](../python-algorithm/algo_01_sort/L315-h.py)
```
题目：给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  
nums[i] 右侧小于 nums[i] 的元素的数量。
```

## 6 颜色分类
75\. Sort Colors

[力扣](https://leetcode-cn.com/problems/sort-colors/) / [Leetcode](https://leetcode.com/problems/sort-colors/) / [Cpp](../algo_01_sort/L75-m.cpp) / [Python3](../python-algorithm/algo_01_sort/L75-m.py)
```
题目：使用整数 0、 1 和 2 分别表示红色、白色和蓝色。常数复杂度排成升序。
```

## 7 按照字符出现次数对字符串排序
451\. Sort Characters By Frequency

[力扣](https://leetcode-cn.com/problems/sort-characters-by-frequency/) / [Leetcode](https://leetcode.com/problems/sort-characters-by-frequency/) / [Cpp](../algo_01_sort/L451-m.cpp) / [Python3](../python-algorithm/algo_01_sort/L451-m.py)
```
题目：给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
```

## 8 任务调度器
621\. Task Scheduler

[力扣](https://leetcode-cn.com/problems/task-scheduler/) / [Leetcode](https://leetcode.com/problems/task-scheduler/) / [Cpp](../algo_01_sort/L621-m.cpp) / [Python3](../python-algorithm/algo_01_sort/L621-m.py)
```
题目：两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的最短时间。
示例：
    输入：tasks = ["A","A","A","B","B","B"], n = 2
    输出：8
    解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
         在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
```
