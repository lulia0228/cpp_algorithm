<!-- GFM-TOC -->
* [1. 返回1-n可以组成的不同二叉搜索树](#1-返回1-n可以组成的不同二叉搜索树)
* [2. 排序链表](#2-排序链表)
* [3. 为运算表达式设计优先级](#3-为运算表达式设计优先级)

<!-- GFM-TOC -->

## 1 返回1-n可以组成的不同二叉搜索树
95\. Unique Binary Search Trees II

[力扣](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) / [Leetcode](https://leetcode.com/problems/unique-binary-search-trees-ii/) / [Cpp](../algo_07_divide_and_conquer/L95-m-copy.cpp)
```
题目：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。
```

## 2 	排序链表  
148\. Sort List

[力扣](https://leetcode-cn.com/problems/sort-list/) / [Leetcode](https://leetcode.com/problems/sort-list/) / [Cpp](../algo_07_divide_and_conquer/L148-m-copy.cpp)
```
题目：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。
```

## 3 为运算表达式设计优先级
241\. Different Ways to Add Parentheses

[力扣](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/) / [Leetcode](https://leetcode.com/problems/different-ways-to-add-parentheses/) / [Cpp](../algo_07_divide_and_conquer/L241-m.cpp)
```
题目：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。
你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。
示例：
    输入: "2*3-4*5"
    输出: [-34, -14, -10, -10, 10]
    解释: 
    (2*(3-(4*5))) = -34 
    ((2*3)-(4*5)) = -14 
    ((2*(3-4))*5) = -10 
    (2*((3-4)*5)) = -10 
    (((2*3)-4)*5) = 10
```
