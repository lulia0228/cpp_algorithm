<!-- GFM-TOC -->   
* [BFS](#BFS)
    * [1. 单词接龙](#1-单词接龙)
    * [2. 完全平方数](#2-完全平方数)
    * [3. 网格中从原点到特定点的最短路径长度](#3-网格中从原点到特定点的最短路径长度)   
    * [4. 地图分析](#4-地图分析)   
    
* [DFS](#DFS)
    * [1. 矩阵中搜索单词](#1-矩阵中搜索单词)
    * [2. 被围绕的区域(填充封闭区域)](#2-被围绕的区域(填充封闭区域))
    * [3. 岛屿数量（矩阵中的连通分量数目）](#3-岛屿数量（矩阵中的连通分量数目）)
    * [4. 能到达的太平洋和大西洋的区域](#4-能到达的太平洋和大西洋的区域)
    * [5. 好友关系的连通分量数目](#5-好友关系的连通分量数目)
    * [6. 查找最大的连通面积](#6-查找最大的连通面积) 
    * [7. 迷路的机器人](#7-迷路的机器人)
    * [8. 水域大小](#8-水域大小)
    * [9. 单词转换](#9-单词转换)
    * [10. 单源最短路](#10-单源最短路)
    
* [其它（拓扑排序、并查集）](#其它（拓扑排序、并查集）)
    * [1. 二分图判断](#1-二分图判断)
    * [2. 课程表I-课程安排的合法性 ](#2-课程表I)
    * [3. 课程表II-课程安排的顺序 ](#3-课程表II)
    * [4. 冗余连接](#4-冗余连接)
    * [5. 节点间通路](#5-节点间通路)
    * [6. 检测循环依赖](#6-检测循环依赖)
    
<!-- GFM-TOC -->

# BFS 
## 1 单词接龙
127\. Word Ladder

[力扣](https://leetcode-cn.com/problems/word-ladder/) / [Leetcode](https://leetcode.com/problems/word-ladder/) / [Cpp](../algo_08_graph/graph_1_bfs/L127-m.cpp)
 / [Python3](../python-algorithm/algo_08_graph/graph_1_bfs/L127-m.py)  

题目：给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度，转换过程每次只能变动一个字母。   
```
输入:   
beginWord = "hit",   
endWord = "cog",   
wordList = ["hot","dot","dog","lot","log","cog"]   
输出: 5  
解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",返回它的长度 5。  
```
    
## 2 完全平方数
279\. Perfect Squares

[力扣](https://leetcode-cn.com/problems/perfect-squares/) / [Leetcode](https://leetcode.com/problems/perfect-squares/) / [Cpp](../algo_08_graph/graph_1_bfs/L279-G.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_1_bfs/L279-m.py)    

题目：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。  

## 3 网格中从原点到特定点的最短路径长度
1091\. Shortest Path in Binary Matrix

[力扣](https://leetcode-cn.com/problems/as-far-from-land-as-possible/) / [Leetcode](https://leetcode.com/problems/as-far-from-land-as-possible/) / [Python3](../python-algorithm/algo_08_graph/graph_1_bfs/L1162-m.py)   

题目：在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）,返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。每个位置处有8个方向可以走。  

## 4 地图分析  
1162\. As Far from Land as Possible

[力扣](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/) / [Leetcode](https://leetcode.com/shortest-path-in-binary-matrix/) / [Cpp](../algo_08_graph/graph_1_bfs/L1162-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_1_bfs/L1091-m.py)   

  


# DFS
## 1 矩阵中搜索单词
79\. Word Search

[力扣](https://leetcode-cn.com/problems/word-search/) / [Leetcode](https://leetcode.com/word-search/) / [Cpp](../algo_08_graph/graph_2_dfs/L79-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L79-m.py)   

示例：   
```   
board =   
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
```   

## 2 被围绕的区域(填充封闭区域)
130\. Surrounded Regions

[力扣](https://leetcode-cn.com/problems/surrounded-regions/) / [Leetcode](https://leetcode.com/surrounded-regions/) / [Cpp](../algo_08_graph/graph_2_dfs/L130-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L130-m.py)  

示例:
```
X X X X      填充后      X X X X
X O O X      -----      X X X X
X X O X      -----      X X X X   
X O X X                 X O X X
```

## 3 岛屿数量（矩阵中的连通分量数目）
200\. Number of Islands

[力扣](https://leetcode-cn.com/problems/number-of-islands/) / [Leetcode](https://leetcode.com/number-of-islands/) / [Cpp](../algo_08_graph/graph_2_dfs/L200-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L200-m.py)   

题目：可以假设该网格的四条边均被水包围。
示例：
```
输入:
[
['1','1','0','0','0'],
['1','1','0','0','0'],
['0','0','1','0','0'],
['0','0','0','1','1']
]
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
```

## 4 能到达的太平洋和大西洋的区域
417\. Pacific Atlantic Water Flow

[力扣](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/) / [Leetcode](https://leetcode.com/pacific-atlantic-water-flow/) / [Cpp](../algo_08_graph/graph_2_dfs/L417-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L417-m.py)   

题目：给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。   

## 5 好友关系的连通分量数目
547\. Friend Circles

[力扣](https://leetcode-cn.com/problems/friend-circles/) / [Leetcode](https://leetcode.com/friend-circles/) / [Cpp](../algo_08_graph/graph_2_dfs/L547-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L547-m.py)   

示例：朋友关系是以邻接矩阵存储的。求有几个独立的圈子。   
```
输入：
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出：2 
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回 2 。
```

## 6 查找最大的连通面积
695\. Max Area of Island

[力扣](https://leetcode-cn.com/problems/max-area-of-island/) / [Leetcode](https://leetcode.com/max-area-of-island/) / [Cpp](../algo_08_graph/graph_2_dfs/L695-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L695-m.py)   

题目：和200求岛屿数量题目类似，只是返回值不是岛屿个数，而是占地面积最大的岛屿的面积。  


## 7 迷路的机器人
面试题 08.02. 迷路的机器人   

[力扣](https://leetcode-cn.com/problems/robot-in-a-grid-lcci/) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/08.02.py) 
```
设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。
设计一种算法，寻找机器人从左上角移动到右下角的路径。

网格中的障碍物和空位置分别用 1 和 0 来表示。
返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。
```

## 8 水域大小
面试题 16.19. 水域大小     

[力扣](https://leetcode-cn.com/problems/pond-sizes-lcci/) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/16.19.py) 
```
你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。
池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。

输入：
         [
           [0,2,1,0],
           [0,1,0,1],
           [1,1,0,1],
           [0,1,0,1]
         ]
输出：      [1,2,4]

```


## 9 单词转换
面试题 17.22. 单词转换   

[力扣](https://leetcode-cn.com/problems/word-transformer-lcci/) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/17.22.py) 
```
给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。
编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。

示例 1:
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]
输出:
["hit","hot","dot","lot","log","cog"]

示例 2:
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]
输出: []
解释: endWord "cog" 不在字典中，所以不存在符合要求的转换序列。
```

## 10 单源最短路  
NC158\. 单源最短路
   
[牛客](https://www.nowcoder.com/practice/9f15b34a2a944a7798a5340ff0dba8b7?tpId=188&&tqId=38651&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/NC158单源最短路径.py) 
```
题目：在一个有向无环图中，已知每条边长，求出1到n的最短路径，返回1到n的最短路径值。如果1无法到n，输出-1
输入：5,5,[[1,2,2],[1,4,5],[2,3,3],[3,5,4],[4,5,5]]
输出:9
```

# 其它（拓扑排序、并查集）
## 1 二分图判断
785\. Is Graph Bipartite?

[力扣](https://leetcode-cn.com/problems/is-graph-bipartite/) / [Leetcode](https://leetcode.com/is-graph-bipartite/) / [Cpp](../algo_08_graph/graph_3_toposort/L785-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_3_toposort/L785-m.py)   

题目：能不能把图中所有节点分成2个集合，要求每个边的2个节点必须在不同的集合中。   
思路：在二分图的情况下，可以使用贪心思想给图着色：一个节点为蓝色，说明它的所有邻接点为红色，它的邻接点的所有邻接点为蓝色，依此类推，在遍历中找出不符合点。    
Tips：这道题和547类似，都是邻接矩阵存储的图表示，使用DFS，每层的遍历对象都是上一层节点的邻接节点。  


```
207 210 2道课程表问题称之为拓扑排序，处理的时候，先转化成邻接矩阵存储，再对邻接矩阵处理，和785 547 一样DFS，每层迭代对象都是上一层的邻接节点。   
```
## 2 课程表I
207\. Course Schedule

[力扣](https://leetcode-cn.com/problems/course-schedule/) / [Leetcode](https://leetcode.com/course-schedule/) / [Cpp](../algo_08_graph/graph_3_toposort/L207-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_3_toposort/L207-m.py)   

题目：你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]。  
示例：  
```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。

输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

## 3 课程表II
210\. Course Schedule II

[力扣](https://leetcode-cn.com/problems/course-schedule-ii/) / [Leetcode](https://leetcode.com/course-schedule-ii/) / [Cpp](../algo_08_graph/graph_3_toposort/L210-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_3_toposort/L210-m.py)   

题目：和207题一样，只是要求返回可以完成课程的顺序，可能有多个答案，返回一个即可。   

## 4 冗余连接
684\. Redundant Connection

[力扣](https://leetcode-cn.com/problems/redundant-connection/) / [Leetcode](https://leetcode.com/redundant-connection/) / [Cpp](../python-algorithm/algo_08_graph/graph_3_toposort/L684-m.cpp)

## 5 节点间通路
面试题 04.01. 节点间通路   

[力扣](https://leetcode-cn.com/problems/route-between-nodes-lcci/) / [Python3](../python-algorithm/algo_08_graph/graph_3_toposort/04.01.py) 
```
节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

示例1:
输入：n = 3, graph = [[0,1], [0,2], [1,2], [1,2]], start = 0, target=2
输出：true
示例2:
输入：n = 5, graph = [[0,1], [0,2], [0,4], [0,4], [0,1], [1,3], [1,4], [1,3], [2,3], [3,4]], start=0, target=4
输出 true

```

## 6 检测循环依赖
补充题  

[Python3](../python-algorithm/algo_08_graph/graph_3_toposort/b检测循环依赖.py) 

