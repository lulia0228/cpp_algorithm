<!-- GFM-TOC -->   
* [BFS](#BFS)
    * [1. 单词接龙](#1-单词接龙)
    * [2. 完全平方数](#2-完全平方数)
    * [3. 网格中从原点到特定点的最短路径长度](#3-网格中从原点到特定点的最短路径长度)   
    
* [DFS](#DFS)
    * [1. 矩阵中搜索单词](#1-矩阵中搜索单词)
    * [2. 被围绕的区域(填充封闭区域)](#2-被围绕的区域(填充封闭区域))
    * [3. 岛屿数量（矩阵中的连通分量数目）](#3-岛屿数量（矩阵中的连通分量数目）)
    * [4. 能到达的太平洋和大西洋的区域](#4-能到达的太平洋和大西洋的区域)
    * [5. 好友关系的连通分量数目](#5-好友关系的连通分量数目)
    * [6. 查找最大的连通面积](#6-查找最大的连通面积) 
    
* [其它（拓扑排序、并查集）](#其它（拓扑排序、并查集）)
    * [1. 二分图判断](#1-二分图判断)
    * [2. 课程表I-课程安排的合法性 ](#2-课程表I)
    * [3. 课程表II-课程安排的顺序 ](#3-课程表II)
    * [4. 冗余连接](#4-冗余连接)
    
<!-- GFM-TOC -->

# BFS 
## 1 单词接龙
127\. Word Ladder

[力扣](https://leetcode-cn.com/problems/word-ladder/) / [Leetcode](https://leetcode.com/problems/word-ladder/) / [Cpp](../algo_08_graph/graph_1_bfs/L127-m.cpp)
 / [Python3](../python-algorithm/algo_08_graph/graph_1_bfs/L127-m.py)  

题目：给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度，转换过程每次只能变动一个字母。   
```
输入:   
beginWord = "hit",   
endWord = "cog",   
wordList = ["hot","dot","dog","lot","log","cog"]   
输出: 5  
解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",返回它的长度 5。  
```
    
## 2 完全平方数
279\. Perfect Squares

[力扣](https://leetcode-cn.com/problems/perfect-squares/) / [Leetcode](https://leetcode.com/problems/perfect-squares/) / [Cpp](../algo_08_graph/graph_1_bfs/L279-G.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_1_bfs/L279-m.py)    

题目：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。  

## 3 网格中从原点到特定点的最短路径长度
1091\. Shortest Path in Binary Matrix

[力扣](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/) / [Leetcode](https://leetcode.com/shortest-path-in-binary-matrix/) / [Cpp](../algo_08_graph/graph_1_bfs/L1091-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_1_bfs/L1091-m.py)   

题目：在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）,返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。每个位置处有8个方向可以走。  

# DFS
## 1 矩阵中搜索单词
79\. Word Search

[力扣](https://leetcode-cn.com/problems/word-search/) / [Leetcode](https://leetcode.com/word-search/) / [Cpp](../algo_08_graph/graph_2_dfs/L79-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L79-m.py)   

示例：   
```   
board =   
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
```   

## 2 被围绕的区域(填充封闭区域)
130\. Surrounded Regions

[力扣](https://leetcode-cn.com/problems/surrounded-regions/) / [Leetcode](https://leetcode.com/surrounded-regions/) / [Cpp](../algo_08_graph/graph_2_dfs/L130-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L130-m.py)  

示例:
```
X X X X      填充后      X X X X
X O O X      -----      X X X X
X X O X      -----      X X X X   
X O X X                 X O X X
```

## 3 岛屿数量（矩阵中的连通分量数目）
200\. Number of Islands

[力扣](https://leetcode-cn.com/problems/number-of-islands/) / [Leetcode](https://leetcode.com/number-of-islands/) / [Cpp](../algo_08_graph/graph_2_dfs/L200-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L200-m.py)   

题目：可以假设该网格的四条边均被水包围。
示例：
```
输入:
[
['1','1','0','0','0'],
['1','1','0','0','0'],
['0','0','1','0','0'],
['0','0','0','1','1']
]
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
```

## 4 能到达的太平洋和大西洋的区域
417\. Pacific Atlantic Water Flow

[力扣](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/) / [Leetcode](https://leetcode.com/pacific-atlantic-water-flow/) / [Cpp](../algo_08_graph/graph_2_dfs/L417-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L417-m.py)   

题目：给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。   

## 5 好友关系的连通分量数目
547\. Friend Circles

[力扣](https://leetcode-cn.com/problems/friend-circles/) / [Leetcode](https://leetcode.com/friend-circles/) / [Cpp](../algo_08_graph/graph_2_dfs/L547-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L547-m.py)   

示例：朋友关系是以邻接矩阵存储的。求有几个独立的圈子。   
```
输入：
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出：2 
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回 2 。
```

## 6 查找最大的连通面积
695\. Max Area of Island

[力扣](https://leetcode-cn.com/problems/max-area-of-island/) / [Leetcode](https://leetcode.com/max-area-of-island/) / [Cpp](../algo_08_graph/graph_2_dfs/L695-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_2_dfs/L695-m.py)   

题目：和200求岛屿数量题目类似，只是返回值不是岛屿个数，而是占地面积最大的岛屿的面积。  

# 其它（拓扑排序、并查集）
## 1 二分图判断
785\. Is Graph Bipartite?

[力扣](https://leetcode-cn.com/problems/is-graph-bipartite/) / [Leetcode](https://leetcode.com/is-graph-bipartite/) / [Cpp](../algo_08_graph/graph_3_toposort/L785-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_3_toposort/L785-m.py)   

题目：能不能把图中所有节点分成2个集合，要求每个边的2个节点必须在不同的集合中。   
思路：在二分图的情况下，可以使用贪心思想给图着色：一个节点为蓝色，说明它的所有邻接点为红色，它的邻接点的所有邻接点为蓝色，依此类推，在遍历中找出不符合点。    
Tips：这道题和547类似，都是邻接矩阵存储的图表示，使用DFS，每层的遍历对象都是上一层节点的邻接节点。  


```
207 210 2道课程表问题称之为拓扑排序，处理的时候，先转化成邻接矩阵存储，在对邻接矩阵处理，和785 547 一样DFS，每层迭代对象都是上一层的邻接节点。   
```
## 2 课程表I
207\. Course Schedule

[力扣](https://leetcode-cn.com/problems/course-schedule/) / [Leetcode](https://leetcode.com/course-schedule/) / [Cpp](../algo_08_graph/graph_3_toposort/L207-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_3_toposort/L207-m.py)   

题目：你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]。  
示例：  
```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。

输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

## 3 课程表II
210\. Course Schedule II

[力扣](https://leetcode-cn.com/problems/course-schedule-ii/) / [Leetcode](https://leetcode.com/course-schedule-ii/) / [Cpp](../algo_08_graph/graph_3_toposort/L210-m.cpp) / [Python3](../python-algorithm/algo_08_graph/graph_3_toposort/L210-m.py)   

题目：和207题一样，只是要求返回可以完成课程顺序的一条路径，可能有多个答案，返回一个即可。   

## 4 冗余连接
684\. Redundant Connection

[力扣](https://leetcode-cn.com/problems/redundant-connection/) / [Leetcode](https://leetcode.com/redundant-connection/) / [Cpp](../algo_08_graph/graph_3_toposort/L684-m.cpp)


