<!-- GFM-TOC -->
* [递归-布尔](#递归返回布尔)
    * [1. 对称二叉树](#1-对称二叉树)
    * [2. 另一个树的子树](#2-另一个树的子树) 
    * [3. 树的子结构](#3-树的子结构) 
    * [4. 路径总和I](#4-路径总和I)
    
* [递归-整数](#递归返回整数)
    * [1. 二叉树的最大深度](#1-二叉树的最大深度)
    * [2. 二叉树的最小深度](#2-二叉树的最小深度)
    * [3. 平衡二叉树](#3-平衡二叉树)
    * [4. 间隔遍历](#4-打家劫舍3) 
    * [5. 分裂二叉树的最大乘积](#5-分裂二叉树的最大乘积)
    * [6. 节点与其祖先之间的最大差值](#6-节点与其祖先之间的最大差值)
    * [7. 具有所有最深节点的最小子树](#7-具有所有最深节点的最小子树)
    * [8. N叉树的最大深度](#8-N叉树的最大深度)
    * [9. 相同节点值的最大路径长度](#9-相同节点值的最大路径长度)
    * [10. 统计左叶子节点的和](#10-统计左叶子节点的和)
 
* [递归-树节点](#递归返回树节点)
    * [1. 二叉树的最近公共祖先](#1-二叉树的最近公共祖先)
    * [2. 翻转二叉树](#2-翻转二叉树)
    * [3. 相同的树](#3-相同的树)
    * [4. 二叉搜索树的最近公共祖先](#4-二叉搜索树的最近公共祖先)
    * [5. 二叉树剪枝](#5-二叉树剪枝)
    * [6. 翻转等价二叉树](#6-翻转等价二叉树) 
    * [7. 删除给定值的叶子节点](#7-删除给定值的叶子节点) 
    * [8. 找出二叉树中第二小的节点](#8-找出二叉树中第二小的节点)
    * [9. 合并二叉树](#9-合并二叉树)
    * [10. 修剪二叉查找树](#10-修剪二叉查找树) 

* [递归-路径问题](#路径问题)
    * [1. 二叉树中的最大路径和](#1-二叉树中的最大路径和)
    * [2. 路径总和II](#2-路径总和II)    
    * [3. 二叉树的直径](#3-二叉树的直径)
    * [4. 求根到叶子节点数字之和](#4-求根到叶子节点数字之和)  
    * [5. 二叉树的所有路径](#5-二叉树的所有路径)
    * [6. 路径总和III](#6-路径总和III)

* [树的遍历](#树的遍历)
    * [1. 前序遍历](#1-前序遍历)
    * [2. 后序遍历](#2-后序遍历)
    * [3. 中序遍历](#3-中序遍历)
    * [4. 层序遍历](#4-层序遍历)
    * [5. 之字形遍历](#5-之字形遍历)
    * [6. 填充每个节点的下一个右侧节点指针](#6-填充每个节点的下一个右侧节点指针)
    * [7. 一棵树每层节点的平均数](#7-一棵树每层节点的平均数)
    * [8. 得到左下角的节点](#8-得到左下角的节点)
    * [9. N叉树的前序遍历](#9-N叉树的前序遍历)
    * [10. N叉树的后序遍历](#10-N叉树的后序遍历)
    * [11. N叉树的层序遍历](#11-N叉树的层序遍历)  
    * [12. 特定深度节点链表](#12-特定深度节点链表)
    * [13. 后继者](#13-后继者)
    * [14. 二叉树的右视图](#14-二叉树的右视图)
    * [15. 判断一棵二叉树是否为搜索二叉树和完全二叉树](#15-判断一棵二叉树是否为搜索二叉树和完全二叉树)

* [二叉搜索树特性](#二叉搜索树特性)
    * [1. 验证二叉搜索树](#1-验证二叉搜索树)
    * [2. 二叉搜索树中的第K小元素](#2-二叉搜索树中的第K小元素)
    * [3. 在二叉查找树中查找两个节点之差的最小绝对值](#3-在二叉查找树中查找两个节点之差的最小绝对值)
    * [4. 在二叉查找树中寻找两个节点，使它们的和为一个定值](#4-在二叉查找树中寻找两个节点，使它们的和为一个定值)
    * [5. 寻找二叉查找树中出现次数最多的值](#5-寻找二叉查找树中出现次数最多的值)
    * [6. 把二叉搜索树转换为累加树](#6-把二叉搜索树转换为累加树)

    
* [树的构建](#树的构建)
    * [1. 从前序与中序遍历序列构造二叉树](#1-从前序与中序遍历序列构造二叉树)
    * [2. 从中序与后序遍历序列构造二叉树](#2-从中序与后序遍历序列构造二叉树)
    * [3. 将有序数组转换为二叉搜索树](#3-将有序数组转换为二叉搜索树)
    * [4. 二叉树的序列化与反序列化](#4-二叉树的序列化与反序列化)
    * [5. 不同的二叉搜索树II](#5-不同的二叉搜索树II)


* [树和链表](#树和链表)
   * [1. 根据有序链表构造平衡的二叉查找树](#1-根据有序链表构造平衡的二叉查找树)
   * [2. 二叉树展开为链表](#2-二叉树展开为链表)
   * [3. 二叉搜索树与双向循环链表](#3-二叉搜索树与双向循环链表)
   
* [字典树](#字典树)
    * [1. 设计字典树](#1-设计字典树)
    * [2. 功能更多的字典树](#2-功能更多的字典树)
    * [3. 实现一个Trie用来求前缀和](#3-实现一个Trie用来求前缀和)
    * [4. Trie单词频率](#4-Trie单词频率)
    * [5. Trie多次搜索](#5-Trie次搜索)

* [其它](#其它)
    * [1. 完全二叉树的节点数](#1-完全二叉树的节点数)
    * [2. 字典序的第K小数字](#2-字典序的第K小数字)
    * [3. 字典序排数](#3-字典序排数)
    * [4. 完全二叉树插入器](#4-完全二叉树插入器)

    
<!-- GFM-TOC -->

C++二叉树表:
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
```
Python二叉树表达:
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
```

# 递归返回布尔
## 1 对称二叉树     
101\. Symmetric Tree

[力扣](https://leetcode-cn.com/problems/symmetric-tree/) / [Leetcode](https://leetcode.com/problems/symmetric-tree/) / [Cpp](../ds_5_tree/tree_1_1_bool_recurrent/L101.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_1_bool_recurrent/L101.py)
```
题目:给定一个二叉树，检查它是否是镜像对称的。
```

## 2 另一个树的子树
572\. Subtree of Another Tree

[力扣](https://leetcode-cn.com/problems/subtree-of-another-tree/) / [Leetcode](https://leetcode.com/problems/subtree-of-another-tree/) / [Cpp](../ds_5_tree/tree_1_1_bool_recurrent/L572.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_1_bool_recurrent/L572.py)
```
题目:给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 
    的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
```

## 3 树的子结构
剑指 Offer 26. 树的子结构

[力扣](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/) / [Cpp](../ds_5_tree/tree_1_1_bool_recurrent/J26-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_1_bool_recurrent/J26-m.py)
```
题目:输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
      B是A的子结构， 即 A中有出现和B相同的结构和节点值。例如:
      
               给定的树 A:

                    3
                   / \
                  4   5
                 / \
                1   2
               给定的树 B：

                  4 
                 /
                1
               返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
```

## 4 路径总和I
112\. Path Sum

[力扣](https://leetcode-cn.com/problems/path-sum/) / [Leetcode](https://leetcode.com/problems/path-sum/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L112.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L112.py)
```
题目：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
```


# 递归返回整数
## 1 二叉树的最大深度
104\. Maximum Depth of Binary Tree

[力扣](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) / [Leetcode](https://leetcode.com/problems/maximum-depth-of-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L104.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L104.py)
```
题目:给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
```

## 2 二叉树的最小深度
111\. Minimum Depth of Binary Tree

[力扣](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) / [Leetcode](https://leetcode.com/problems/minimum-depth-of-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L111.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L111.py)
```
题目:给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
```

## 3 平衡二叉树
110\. Balanced Binary Tree

[力扣](https://leetcode-cn.com/problems/balanced-binary-tree/) / [Leetcode](https://leetcode.com/balanced-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L110.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L110.py)
```
题目:给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。
```

## 4 打家劫舍3
337\. House Robber III 

[力扣](https://leetcode-cn.com/problems/house-robber-iii/) / [Leetcode](https://leetcode.com/problems/house-robber-iii/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L337-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L337-m.py)
```
题目：抢劫根形分布的社区，不得同时抢劫有直接连接的2个房子，求最大可抢劫量。

         示例 1:
         输入: [3,2,3,null,3,null,1]

              3
             / \
            2   3
             \   \ 
              3   1

         输出: 7 
         解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

         示例 2:
         输入: [3,4,5,1,3,null,1]

              3
             / \
            4   5
           / \   \ 
          1   3   1

         输出: 9
         解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```

## 5 分裂二叉树的最大乘积
1339\. Maximum Product of Splitted Binary Tree

[力扣](https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/) / [Leetcode](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L1339-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L1339-m.py)
```
题目:给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。
由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。
```

## 6 节点与其祖先之间的最大差值
1026\. Maximum Difference Between Node and Ancestor

[力扣](https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/) / [Leetcode](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L1026-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L1026-m.py)
```
给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，
其中 V = |A.val - B.val|，且 A 是 B 的祖先。
（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）
```

## 7 具有所有最深节点的最小子树
865\. Smallest Subtree with all the Deepest Nodes

[力扣](https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/) / [Leetcode](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L865-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L865-m.py)
```
题目:给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。
   如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。
   一个节点的 子树 是该节点加上它的所有后代的集合。
   返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。
```

## 8 N叉树的最大深度
559\. Maximum Depth of N-ary Tree

[力扣](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/) / [Leetcode](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L559.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L559.py)
```
题目:给定一个 N 叉树，找到其最大深度。
    最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
```

## 9 相同节点值的最大路径长度
687\. Longest Univalue Path

[力扣](https://leetcode-cn.com/problems/longest-univalue-path/) / [Leetcode](https://leetcode.com/problems/longest-univalue-path/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L687.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L687.py)
```
题目:给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。
注意：两个节点之间的路径长度由它们之间的边数表示。
输入:

              1
             / \
            4   5
           / \   \
          4   4   5

输出：2
```

## 10 统计左叶子节点的和
404\. Sum of Left Leaves

[力扣](https://leetcode-cn.com/problems/sum-of-left-leaves/) / [Leetcode](https://leetcode.com/problems/sum-of-left-leaves/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L404.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L404.py)
```
题目:计算给定二叉树的所有左叶子之和。
```

# 递归返回树节点
## 1 二叉树的最近公共祖先
236\. Lowest Common Ancestor of a Binary Tree

[力扣](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) / [Leetcode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L236-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L236-m.py)
```
题目:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
    百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
    满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```

## 2 翻转二叉树
226\. Invert Binary Tree

[力扣](https://leetcode-cn.com/problems/invert-binary-tree/) / [Leetcode](https://leetcode.com/problems/invert-binary-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L226.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L226.py)
```
题目:翻转一棵二叉树。
输入：               输出：    

     4                   4
   /   \               /   \
  2     7             7     2
 / \   / \           / \   / \
1   3 6   9         1   3 6   9
```

## 3 相同的树
100\. Same Tree

[力扣](https://leetcode-cn.com/problems/same-tree/) / [Leetcode](https://leetcode.com/problems/same-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L100.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L100.py)


## 4 二叉搜索树的最近公共祖先
235\. Lowest Common Ancestor of a Binary Search Tree

[力扣](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L235.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L235.py)
```
题目:给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
    百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
    满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```

## 5 二叉树剪枝
814\. Binary Tree Pruning

[力扣](https://leetcode-cn.com/problems/binary-tree-pruning/) / [Leetcode](https://leetcode.com/problems/binary-tree-pruning/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L814-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L814-m.py)
```
题目:给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。
   返回移除了所有不包含 1 的子树的原二叉树。 
   ( 节点 X 的子树为 X 本身，以及所有 X 的后代。)
```

## 6 翻转等价二叉树
951\. Flip Equivalent Binary Trees 

[力扣](https://leetcode-cn.com/problems/flip-equivalent-binary-trees/) / [Leetcode](https://leetcode.com/problems/flip-equivalent-binary-trees/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L951-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L951-m.py)
```
题目:我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。
     只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。
     编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。
示例：
输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
输出：true
解释：我们翻转值为 1，3 以及 5 的三个节点。
```

## 7 删除给定值的叶子节点
1325\. Delete Leaves With a Given Value

[力扣](https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/) / [Leetcode](https://leetcode.com/problems/delete-leaves-with-a-given-value/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L1325-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L1325-m.py)
```
题目:给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。
      注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；
      如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。
      也就是说，你需要重复此过程直到不能继续删除。
```

## 8 找出二叉树中第二小的节点
671\. Second Minimum Node In a Binary Tree

[力扣](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/) / [Leetcode](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L671.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L671.py)
```
题目:给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，
    那么该节点的值等于两个子节点中较小的一个。
    给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1:
      输入: 
          2
         / \
        2   5
           / \
          5   7
      输出: 5
      说明: 最小的值是 2 ，第二小的值是 5 。
```


## 9 合并二叉树
617\. Merge Two Binary Trees

[力扣](https://leetcode-cn.com/problems/merge-two-binary-trees/) / [Leetcode](https://leetcode.com/problems/merge-two-binary-trees/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L617.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L617.py)
```
      输入: 
         Tree 1                     Tree 2                  
                1                         2                             
               / \                       / \                            
              3   2                     1   3                        
             /                           \   \                      
            5                             4   7                  
      输出: 
      合并后的树:
              3
             / \
            4   5
           / \   \ 
          5   4   7
```

## 10 修剪二叉查找树
669\. Trim a Binary Search Tree

[力扣](https://leetcode-cn.com/problems/trim-a-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/trim-a-binary-search-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L669.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L669.py)
```
题目：给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。
     你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。
     
      输入:  L = 1  R = 3              输出:                
          3                            3
         / \                          /
        0   4                        2 
         \                          /
          2                        1 
         /
        1
```

# 路径问题

## 1 二叉树中的最大路径和
124\. Binary Tree Maximum Path Sum (hard)

[牛客](https://www.nowcoder.com/practice/da785ea0f64b442488c125b441a4ba4a?tpId=117&&tqId=37716&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking) / [力扣](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) / [Leetcode](https://leetcode.com/problems/binary-tree-maximum-path-sum/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L124-h.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L124-h.py)
```
题目:给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，
    达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
```

## 2 路径总和II 
113\. Path Sum II

[力扣](https://leetcode-cn.com/problems/path-sum-ii/) / [Leetcode](https://leetcode.com/problems/path-sum-ii/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L113-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L113-m.py)
```
题目:给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。
示例:
给定如下二叉树，以及目标和 sum = 22，               返回:

              5                                [
             / \                                 [5,4,11,2],
            4   8                                [5,8,4,5]
           /   / \                             ]
          11  13  4
         /  \    / \
        7    2  5   1
```

## 3 二叉树的直径
543\. Diameter of Binary Tree

[力扣](https://leetcode-cn.com/problems/diameter-of-binary-tree/) / [Leetcode](https://leetcode.com/problems/diameter-of-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L543.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L543.py)
```
题目:给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```

## 4 求根到叶子节点数字之和
129\. 求根节点到叶节点数字之和

[力扣](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/) / [Leetcode](https://leetcode.com/problems/sum-root-to-leaf-numbers/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L129-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L129-m.py)
```
题目:给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
   每条从根节点到叶节点的路径都代表一个数字：
      例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
   计算从根节点到叶节点生成的 所有数字之和 。
   叶节点 是指没有子节点的节点。
示例
输入：root = [1,2,3]
输出：25
解释：
      从根到叶子节点路径 1->2 代表数字 12
      从根到叶子节点路径 1->3 代表数字 13
      因此，数字总和 = 12 + 13 = 25
```

## 5 二叉树的所有路径
257\. Binary Tree Paths

[力扣](https://leetcode-cn.com/problems/binary-tree-paths/) / [Leetcode](https://leetcode.com/problems/binary-tree-paths/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L257.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L257.py)
```
题目:给定一个二叉树，返回所有从根节点到叶子节点的路径。
```

## 6 路径总和III
437\. Path Sum III

[力扣](https://leetcode-cn.com/problems/path-sum-iii/) / [Leetcode](https://leetcode.com/problems/path-sum-iii/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L437.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L437.py)
```
题目:给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。
    路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
    二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。
示例：
         root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

               10
              /  \
             5   -3
            / \    \
           3   2   11
          / \   \
         3  -2   1

         返回 3。和等于 8 的路径有:

         1.  5 -> 3
         2.  5 -> 2 -> 1
         3.  -3 -> 11
```



# 树的遍历
```
class Solution:
    def threeOrders(self , root ):
        # write code here
        def preOrder(root):
            res = []
            if not root: return res
            stk = [(root, "go")]
            while stk:
                cur_nd = stk.pop()
                if cur_nd[1] == "print":
                    res.append(cur_nd[0].val)
                else:
                    if cur_nd[0].right:
                        stk.append((cur_nd[0].right, "go"))
                    if cur_nd[0].left:
                        stk.append((cur_nd[0].left, "go"))
                    stk.append((cur_nd[0], "print"))
            return res
                
        def inOrder(root):
            res = []
            if not root: return res
            stk = [(root, "go")]
            while stk:
                cur_nd = stk.pop()
                if cur_nd[1] == "print":
                    res.append(cur_nd[0].val)
                else:
                    if cur_nd[0].right:
                        stk.append((cur_nd[0].right, "go"))
                    stk.append((cur_nd[0], "print"))
                    if cur_nd[0].left:
                        stk.append((cur_nd[0].left, "go"))
            return res
        
        def postOrder(root):
            res = []
            if not root: return res
            stk = [(root, "go")]
            while stk:
                cur_nd = stk.pop()
                if cur_nd[1] == "print":
                    res.append(cur_nd[0].val)
                else:
                    stk.append((cur_nd[0], "print"))
                    if cur_nd[0].right:
                        stk.append((cur_nd[0].right, "go"))
                    if cur_nd[0].left:
                        stk.append((cur_nd[0].left, "go"))
            return res
        
        res = []
        if not root: return res
        res.append(preOrder(root))
        res.append(inOrder(root))
        res.append(postOrder(root))
        return res
```
## 1 前序遍历
144\. Binary Tree Preorder Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-preorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L144-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L144-m.py)

## 2 后序遍历
145\. Binary Tree Postorder Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-postorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L145-h.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L145-h.py)

## 3 中序遍历
94\. Binary Tree Inorder Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-inorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L94-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L94-m.py)

## 4 层序遍历
102\. Binary Tree Level Order Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-level-order-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L102-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L102-m.py)

## 5 之字形遍历
103\. Binary Tree Zigzag Level Order Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L103-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L103-m.py)
```
题目:给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
给定二叉树 [3,9,20,null,null,15,7],                 返回锯齿形层次遍历如下：

    3                                             [
   / \                                              [3],
  9  20                                             [20,9],
    /  \                                            [15,7]
   15   7                                         ]
```

## 6 填充每个节点的下一个右侧节点指针
116\. Populating Next Right Pointers in Each Node

[力扣](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/) / [Leetcode](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/) / [Cpp](../ds_5_tree/tree_2_traversal/L116-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L116-m.py)
```
题目:给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
```

## 7 一棵树每层节点的平均数
637\. Average of Levels in Binary Tree

[力扣](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/) / [Leetcode](https://leetcode.com/problems/average-of-levels-in-binary-tree/) / [Cpp](../ds_5_tree/tree_2_traversal/L637.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L637.py)
```
题目:给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
```

## 8 得到左下角的节点
513\. Find Bottom Left Tree Value

[力扣](https://leetcode-cn.com/problems/find-bottom-left-tree-value/) / [Leetcode](https://leetcode.com/problems/find-bottom-left-tree-value/) / [Cpp](../ds_5_tree/tree_2_traversal/L513-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L513-m.py)
```
题目:给定一个二叉树，在树的最后一行找到最左边的值。
```

## 9 N叉树的前序遍历
589\. N-ary Tree Preorder Traversal

[力扣](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/) / [Leetcode](https://leetcode.com/problems/n-ary-tree-preorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L589.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L589.py)


## 10 N叉树的后序遍历
590\. N-ary Tree Postorder Traversal

[力扣](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/) / [Leetcode](https://leetcode.com/problems/n-ary-tree-postorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L590.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L590.py)

## 11 N叉树的层序遍历
429\. N-ary Tree Level Order Traversal

[力扣](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/) / [Leetcode](https://leetcode.com/problems/n-ary-tree-level-order-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L429-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L429-m.py)

## 12 特定深度节点链表        
面试题 04.03. 特定深度节点链表     

[力扣](https://leetcode-cn.com/problems/list-of-depth-lcci/) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/04.03.py)      
```
给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。

输入：[1,2,3,4,5,null,7,8]

        1
       /  \ 
      2    3
     / \    \ 
    4   5    7
   /
  8

输出：[[1],[2,3],[4,5,7],[8]]
```

## 13 后继者  
面试题 04.06. 后继者       

[力扣](https://leetcode-cn.com/problems/successor-lcci/) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/04.06.py)      
```
设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。
如果指定节点没有对应的“下一个”节点，则返回null。

输入: root = [2,1,3], p = 1
           2
          / \
         1   3

输出: 2
```
## 14 二叉树的右视图    
199\. 二叉树的右视图      

[力扣](https://leetcode-cn.com/problems/binary-tree-right-side-view/) /[牛客](https://www.nowcoder.com/practice/c9480213597e45f4807880c763ddd5f0?tpId=117&&tqId=37848&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking
) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L199-m.py)      
```
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
```

## 15 判断一棵二叉树是否为搜索二叉树和完全二叉树    
NC60\. 判断一棵二叉树是否为搜索二叉树和完全二叉树      

[牛客](https://www.nowcoder.com/practice/f31fc6d3caf24e7f8b4deb5cd9b5fa97?tpId=117&&tqId=37822&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking
) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/NC60.py)      
```
给定一棵二叉树，已知其中的节点没有重复值，请判断该二叉树是否为搜索二叉树和完全二叉树。
```


# 二叉搜索树特性
## 1 验证二叉搜索树 
98\. Validate Binary Search Tree

[力扣](https://leetcode-cn.com/problems/validate-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/validate-binary-search-tree/) / [Cpp](../ds_5_tree/tree_3_bst_property/L98-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L98-m.py)
```
题目:给定一个二叉树，判断其是否是一个有效的二叉搜索树。
    假设一个二叉搜索树具有如下特征：
      节点的左子树只包含小于当前节点的数。
      节点的右子树只包含大于当前节点的数。
      所有左子树和右子树自身必须也是二叉搜索树。
```

## 2 二叉搜索树中的第K小元素
230\. Kth Smallest Element in a BST

[力扣](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/) / [Leetcode](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) / [Cpp](../ds_5_tree/tree_3_bst_property/L230-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L230-m.py)

## 3 在二叉查找树中查找两个节点之差的最小绝对值
530\. Minimum Absolute Difference in BST

[力扣](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/) / [Leetcode](https://leetcode.com/problems/minimum-absolute-difference-in-bst/) / [Cpp](../ds_5_tree/tree_3_bst_property/L530.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L530.py)

## 4 在二叉查找树中寻找两个节点，使它们的和为一个定值
653\. Two Sum IV - Input is a BST

[力扣](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/) / [Leetcode](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) / [Cpp](../ds_5_tree/tree_3_bst_property/L653.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L653.py)
```
题目:给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。
```

## 5 寻找二叉查找树中出现次数最多的值
501\. Find Mode in Binary Search Tree

[力扣](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/find-mode-in-binary-search-tree/) / [Cpp](../ds_5_tree/tree_3_bst_property/L501.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L501.py)
```
题目:给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
    假定 BST 有如下定义：
      1 结点左子树中所含结点的值小于等于当前结点的值
      2 结点右子树中所含结点的值大于等于当前结点的值
      3 左子树和右子树都是二叉搜索树
提示：如果众数超过1个，不需考虑输出顺序
进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）
```

## 6 把二叉搜索树转换为累加树
538\. Convert BST to Greater Tree

[力扣](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/) / [Leetcode](https://leetcode.com/problems/convert-bst-to-greater-tree/) / [Cpp](../ds_5_tree/tree_3_bst_property/L538.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L538.py)
```
题目：给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），
     使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
```

# 树的构建
## 1 从前序与中序遍历序列构造二叉树
105\. Construct Binary Tree from Preorder and Inorder Traversal

[力扣](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) / [Leetcode](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) / [Cpp](../ds_5_tree/tree_4_build_tree/L105-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L105-m.py)
```
你可以假设树中没有重复的元素。例如，给出

      前序遍历 preorder = [3,9,20,15,7]
      中序遍历 inorder = [9,3,15,20,7]
      
返回如下的二叉树：
          3
         / \
        9  20
          /  \
         15   7
```

## 2 从中序与后序遍历序列构造二叉树
106\. Construct Binary Tree from Inorder and Postorder Traversal

[力扣](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) / [Leetcode](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) / [Cpp](../ds_5_tree/tree_4_build_tree/L106-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L106-m.py)
```
你可以假设树中没有重复的元素。例如，给出

      中序遍历 inorder = [9,3,15,20,7]
      后序遍历 postorder = [9,15,7,20,3]
      
返回如下的二叉树：
       3
      / \
     9  20
       /  \
      15   7
```

## 3 将有序数组转换为二叉搜索树
108\. Convert Sorted Array to Binary Search Tree

[力扣](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) / [Cpp](../ds_5_tree/tree_4_build_tree/L108.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L108.py)
```
题目:将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。
    本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
    给定有序数组: [-10,-3,0,5,9],
    一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

            0
           / \
         -3   9
         /   /
       -10  5
```

## 4 二叉树的序列化与反序列化
297\. Serialize and Deserialize Binary Tree

[力扣](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) / [Leetcode](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) / [Cpp](../ds_5_tree/tree_4_build_tree/L297-h.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L297-h.py)
```
题目:序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，
    同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
    请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证
    一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

示例: 
         你可以将以下二叉树：

             1
            / \
           2   3
              / \
             4   5

         序列化为 "[1,2,3,null,null,4,5]"
提示: 这与 LeetCode 目前使用的方式一致。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。
```

## 5 不同的二叉搜索树II
95\. Unique Binary Search Trees II

[力扣](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) / [Leetcode](https://leetcode.com/problems/unique-binary-search-trees-ii/) /  [Cpp](../ds_5_tree/tree_4_build_tree/L95-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L95-m.py)
```
题目:给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。
```

# 树和链表  
## 1 根据有序链表构造平衡的二叉查找树
109\. Convert Sorted List to Binary Search Tree

[力扣](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/) / [Cpp](../ds_5_tree/tree_5_tree_and_linkedlist/L109-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_5_tree_and_linkedlist/L109-m.py)
```
题目:给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
    本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
    给定的有序链表： [-10, -3, 0, 5, 9],
    一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

            0
           / \
         -3   9
         /   /
       -10  5
```

## 2 二叉树展开为链表  
114\. Flatten Binary Tree to Linked List

[力扣](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/) / [Leetcode](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/) / [Cpp](../ds_5_tree/tree_5_tree_and_linkedlist/L114-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_5_tree_and_linkedlist/L114-m.py)
```
题目:给定一个二叉树，原地将它展开为一个单链表。
    例如，给定二叉树
                1
               / \
              2   5
             / \   \
            3   4   6
将其展开为：
               1
                \
                 2
                  \
                   3
                    \
                     4
                      \
                       5
                        \
                         6
```

## 3 二叉搜索树与双向循环链表
剑指offer36 leetcode426(锁)

[力扣](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) / [Cpp](../ds_5_tree/tree_5_tree_and_linkedlist/J36-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_5_tree_and_linkedlist/J36-m.py)
```
题目:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
```

# 字典树
## 1 设计字典树
208\. Implement Trie (Prefix Tree)

[力扣](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) / [Leetcode](https://leetcode.com/problems/implement-trie-prefix-tree/) / [Cpp](../ds_5_tree/tree_6_trie_tree/L208-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_6_trie_tree/L208-m.py)
```
题目:实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。

示例:
      Trie trie = new Trie();

      trie.insert("apple");
      trie.search("apple");   // 返回 true
      trie.search("app");     // 返回 false
      trie.startsWith("app"); // 返回 true
      trie.insert("app");   
      trie.search("app");     // 返回 true
说明:
      你可以假设所有的输入都是由小写字母 a-z 构成的。
      保证所有输入均为非空字符串。
```
## 2 功能更多的字典树
NC124\.   功能更多的字典树

[牛客](https://www.nowcoder.com/practice/a55a584bc0ca4a83a272680174be113b?tpId=117&&tqId=37818&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking) / [Python3](../python-algorithm/ds_5_tree/tree_6_trie_tree/NC124实现字典树.py)      
```
字典树又称为前缀树或者Trie树，是处理字符串常用的数据结构。假设组成所有单词的字符仅是‘a’～‘z’，
请实现字典树的结构，并包含以下四个主要的功能。
void insert(String word)：添加word，可重复添加；
void delete(String word)：删除word，如果word添加过多次，仅删除一次；
boolean search(String word)：查询word是否在字典树中出现过(完整的出现过，前缀式不算)；
int prefixNumber(String pre)：返回以字符串pre作为前缀的单词数量。
现在给定一个m，表示有m次操作，每次操作都为以上四种操作之一。每次操作会给定一个整数op和一个字符串word，
op代表一个操作码，如果op为1，则代表添加word，op为2则代表删除word，op为3则代表查询word是否在字典树中，
op为4代表返回以word为前缀的单词数量（数据保证不会删除不存在的word）。

对于每次操作，如果op为3时，如果word在字典树中，请输出“YES”，否则输出“NO”；如果op为4时，请输出返回以word为前缀的单词数量，其它情况不输出。

示例1
    输入：   [["1","qwer"],["1","qwe"],["3","qwer"],["4","q"],["2","qwer"],["3","qwer"],["4","q"]]
    返回值： ["YES","2","NO","1"]
```

## 3 实现一个Trie用来求前缀和
677\. Map Sum Pairs

[力扣](https://leetcode-cn.com/problems/map-sum-pairs/) / [Leetcode](https://leetcode.com/problems/map-sum-pairs/) / [Cpp](../ds_5_tree/tree_6_trie_tree/L677-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_6_trie_tree/L677-m.py)
```
实现一个 MapSum 类里的两个方法，insert 和 sum。
对于方法 insert，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。
对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。

示例 1:
      输入: insert("apple", 3), 输出: Null
      输入: sum("ap"), 输出: 3
      输入: insert("app", 2), 输出: Null
      输入: sum("ap"), 输出: 5
```

## 4 Trie单词频率  
面试题 16.02. 单词频率    

[力扣](https://leetcode-cn.com/problems/words-frequency-lcci/) / [Python3](../python-algorithm/ds_5_tree/tree_6_trie_tree/16.02.py)      
```
设计一个方法，找出任意指定单词在一本书中的出现频率。
你的实现应该支持如下操作：

WordsFrequency(book)构造函数，参数为字符串数组构成的一本书
get(word)查询指定单词在书中出现的频率
示例：

WordsFrequency wordsFrequency = new WordsFrequency({"i", "have", "an", "apple", "he", "have", "a", "pen"});
wordsFrequency.get("you"); //返回0，"you"没有出现过
wordsFrequency.get("have"); //返回2，"have"出现2次
wordsFrequency.get("an"); //返回1
wordsFrequency.get("apple"); //返回1
wordsFrequency.get("pen"); //返回1
```

## 5 Trie多次搜索
面试题 17.17. 多次搜索  

[力扣](https://leetcode-cn.com/problems/multi-search-lcci/) / [Python3](../python-algorithm/ds_5_tree/tree_6_trie_tree/17.17.py)      
```
给定一个较长字符串big和一个包含较短字符串的数组smalls，设计一个方法，根据smalls中的每一个较短字符串，
对big进行搜索。输出smalls中的字符串在big里出现的所有位置positions，其中positions[i]为smalls[i]出现的所有位置。

输入：
big = "mississippi"
smalls = ["is","ppi","hi","sis","i","ssippi"]
输出： [[1,4],[8],[],[3],[1,4,7,10],[5]]
```

# 其他
## 1 完全二叉树的结点数
222\. Unique Binary Search Trees II

[牛客](https://www.nowcoder.com/practice/512688d2ecf54414826f52df4e4b5693?tpId=117&&tqId=37786&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking) / [力扣](https://leetcode-cn.com/problems/count-complete-tree-nodes/) / [Leetcode](https://leetcode.com/problems/count-complete-tree-nodes/) /  [Cpp](../ds_5_tree/tree_4_build_tree/L95-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L222-m.py)
```
给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，
并且最下面一层的节点都集中在该层最左边的若干位置。
若最底层为第 h 层，则该层包含 1~ 2h 个节点。
```

## 2 字典序的第K小数字
440\. 字典序的第K小数字 Hard

[力扣](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/) / [Python3](../python-algorithm/ds_5_tree/tree_7_other_tree/L440-h.py)      
```
给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。注意：1 ≤ k ≤ n ≤ 109。
输入:   n: 13   k: 2
输出:   10
解释:字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```

## 3 字典序排数
386\. 字典序排数

[力扣](https://leetcode-cn.com/problems/lexicographical-numbers/) / [Python3](../python-algorithm/ds_5_tree/tree_7_other_tree/L386-m.py)      
```
给定一个整数 n, 返回从 1 到 n 的字典顺序。
例如，给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。
请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。
```

## 4 完全二叉树插入器
919\. 完全二叉树插入器

[力扣](https://leetcode-cn.com/problems/complete-binary-tree-inserter/) / [Python3](../python-algorithm/ds_5_tree/tree_7_other_tree/L919-m.py)      
```
完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。
设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：
CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；
CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。
使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；
CBTInserter.get_root() 将返回树的头节点。

```
