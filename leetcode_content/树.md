<!-- GFM-TOC -->
* [递归-布尔](#递归返回布尔)
    * [1. 对称二叉树](#1-对称二叉树)
    * [2. 另一个树的子树](#2-另一个树的子树) 
    
* [递归-整数](#递归返回整数)
    * [1. 二叉树的最大深度](#1-二叉树的最大深度)
    * [2. 二叉树的最小深度](#2-二叉树的最小深度)
    * [3. 平衡二叉树](#3-平衡二叉树)
    * [4. 二叉树的直径](#4-二叉树的直径)
    * [5. 相同节点值的最大路径长度](#5-相同节点值的最大路径长度)
    * [6. N叉树的最大深度](#6-N叉树的最大深度)
    
* [递归-树节点](#递归返回树节点)
    * [1. 翻转二叉树](#1-翻转二叉树)
    * [2. 二叉搜索树的最近公共祖先](#2-二叉搜索树的最近公共祖先)
    * [3. 二叉树的最近公共祖先](#3-二叉树的最近公共祖先)
    * [4. 合并二叉树](#4-合并二叉树)
    * [5. 找出二叉树中第二小的节点](#5-找出二叉树中第二小的节点)
    * [6. 修剪二叉查找树](#6-修剪二叉查找树) 
    
* [递归-路径问题](#路径问题)
    * [1. 路径总和I](#1-路径总和I)
    * [2. 路径总和II](#2-路径总和II)
    * [3. 二叉树中的最大路径和](#3-二叉树中的最大路径和)
    * [4. 二叉树的所有路径](#4-二叉树的所有路径)
    * [5. 统计左叶子节点的和](#5-统计左叶子节点的和)
    * [6. 路径总和III](#6-路径总和III)
    * [7. 间隔遍历](#7-间隔遍历) 
    
* [树的遍历](#树的遍历)
    * [1. 前序遍历](#1-前序遍历)
    * [2. 后序遍历](#2-后序遍历)
    * [3. 中序遍历](#3-中序遍历)
    * [4. 层序遍历](#4-层序遍历)
    * [5. 之字形遍历](#5-之字形遍历)
    * [6. 填充每个节点的下一个右侧节点指针](#6-填充每个节点的下一个右侧节点指针)
    * [7. 一棵树每层节点的平均数](#7-一棵树每层节点的平均数)
    * [8. 得到左下角的节点](#8-得到左下角的节点)
    * [9. 二叉树的序列化与反序列化](#9-二叉树的序列化与反序列化)
    * [10. N叉树的前序遍历](#10-N叉树的前序遍历)
    * [11. N叉树的后序遍历](#11-N叉树的后序遍历)
    * [12. N叉树的层序遍历](#12-N叉树的层序遍历)  
    
* [二叉搜索树特性](#二叉搜索树特性)
    * [1. 验证二叉搜索树](#1-验证二叉搜索树)
    * [2. 二叉搜索树中的第K小元素](#2-二叉搜索树中的第K小元素)
    * [3. 寻找二叉查找树中出现次数最多的值](#3-寻找二叉查找树中出现次数最多的值)
    * [4. 在二叉查找树中查找两个节点之差的最小绝对值](#4-在二叉查找树中查找两个节点之差的最小绝对值)
    * [5. 把二叉搜索树转换为累加树](#5-把二叉搜索树转换为累加树)
    * [6. 组合总和](#6-组合总和)
    * [7. 在二叉查找树中寻找两个节点，使它们的和为一个定值](#7-在二叉查找树中寻找两个节点，使它们的和为一个定值)
    
* [树的构建](#树的构建)
    * [1. 从前序与中序遍历序列构造二叉树](#1-从前序与中序遍历序列构造二叉树)
    * [2. 从中序与后序遍历序列构造二叉树](#2-从中序与后序遍历序列构造二叉树)
    * [3. 不同的二叉搜索树II](#3-不同的二叉搜索树II)
    * [4. 将有序数组转换为二叉搜索树](#4-将有序数组转换为二叉搜索树)
    * [5. 根据有序链表构造平衡的二叉查找树](#5-根据有序链表构造平衡的二叉查找树)

* [树和链表](#树和链表)
   * [1. 二叉树展开为链表](#1-二叉树展开为链表)
   * [2. 二叉搜索树与双向循环链表](#2-二叉搜索树与双向循环链表)
   
* [字典树](#字典树)
    * [1. 设计字典树](#1-设计字典树)
    * [2. 实现一个Trie用来求前缀和](#2-实现一个Trie用来求前缀和)
<!-- GFM-TOC -->
C++二叉树表:
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
```
Python二叉树表达:
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
```

# 递归返回布尔
## 1 对称二叉树     
101\. Symmetric Tree

[力扣](https://leetcode-cn.com/problems/symmetric-tree/) / [Leetcode](https://leetcode.com/problems/symmetric-tree/) / [Cpp](../ds_5_tree/tree_1_1_bool_recurrent/L101.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_1_bool_recurrent/L101.py)
```
题目:给定一个二叉树，检查它是否是镜像对称的。
```

## 2 另一个树的子树
572\. Subtree of Another Tree

[力扣](https://leetcode-cn.com/problems/subtree-of-another-tree/) / [Leetcode](https://leetcode.com/problems/subtree-of-another-tree/) / [Cpp](../ds_5_tree/tree_1_1_bool_recurrent/L572.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_1_bool_recurrent/L572.py)
```
题目:给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 
    的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
```

# 递归返回整数
## 1 二叉树的最大深度
104\. Maximum Depth of Binary Tree

[力扣](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) / [Leetcode](https://leetcode.com/problems/maximum-depth-of-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L104.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L104.py)
```
题目:给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
```

## 2 二叉树的最小深度
111\. Minimum Depth of Binary Tree

[力扣](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) / [Leetcode](https://leetcode.com/problems/minimum-depth-of-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L111.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L111.py)
```
题目:给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
```

## 3 平衡二叉树
110\. Balanced Binary Tree

[力扣](https://leetcode-cn.com/problems/balanced-binary-tree/) / [Leetcode](https://leetcode.com/balanced-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L110.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L110.py)
```
题目:给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。
```

## 4 二叉树的直径
543\. Diameter of Binary Tree

[力扣](https://leetcode-cn.com/problems/diameter-of-binary-tree/) / [Leetcode](https://leetcode.com/problems/diameter-of-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L543.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L543.py)
```
题目:给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```

## 5 相同节点值的最大路径长度
687\. Longest Univalue Path

[力扣](https://leetcode-cn.com/problems/longest-univalue-path/) / [Leetcode](https://leetcode.com/problems/longest-univalue-path/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L687.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L687.py)
```
题目:给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。
注意：两个节点之间的路径长度由它们之间的边数表示。
输入:

              1
             / \
            4   5
           / \   \
          4   4   5

输出：2
```

## 6 N叉树的最大深度
559\. Maximum Depth of N-ary Tree

[力扣](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/) / [Leetcode](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L559.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_2_inter_recurrent/L559.py)
```
题目:给定一个 N 叉树，找到其最大深度。
    最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
```


# 递归返回树节点
## 1 翻转二叉树
226\. Invert Binary Tree

[力扣](https://leetcode-cn.com/problems/invert-binary-tree/) / [Leetcode](https://leetcode.com/problems/invert-binary-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L226.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L226.py)
```
题目:翻转一棵二叉树。
输入：               输出：    

     4                   4
   /   \               /   \
  2     7             7     2
 / \   / \           / \   / \
1   3 6   9         1   3 6   9
```

## 2 二叉搜索树的最近公共祖先
235\. Lowest Common Ancestor of a Binary Search Tree

[力扣](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L235.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L235.py)
```
题目:给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
    百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
    满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```

## 3 二叉树的最近公共祖先
236\. Lowest Common Ancestor of a Binary Tree

[力扣](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) / [Leetcode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L236-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L236-m.py)
```
题目:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
    百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
    满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```

## 4 合并二叉树
617\. Merge Two Binary Trees

[力扣](https://leetcode-cn.com/problems/merge-two-binary-trees/) / [Leetcode](https://leetcode.com/problems/merge-two-binary-trees/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L617.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L617.py)
```
      输入: 
         Tree 1                     Tree 2                  
                1                         2                             
               / \                       / \                            
              3   2                     1   3                        
             /                           \   \                      
            5                             4   7                  
      输出: 
      合并后的树:
              3
             / \
            4   5
           / \   \ 
          5   4   7
```

## 5 找出二叉树中第二小的节点
671\. Second Minimum Node In a Binary Tree

[力扣](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/) / [Leetcode](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L671.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L671.py)
```
题目:给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，
    那么该节点的值等于两个子节点中较小的一个。
    给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1:
      输入: 
          2
         / \
        2   5
           / \
          5   7
      输出: 5
      说明: 最小的值是 2 ，第二小的值是 5 。
```

## 6 修剪二叉查找树
669\. Trim a Binary Search Tree

[力扣](https://leetcode-cn.com/problems/trim-a-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/trim-a-binary-search-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L669.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_3_node_recurrent/L669.py)
```
题目：给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。
     你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。
     
      输入:  L = 1  R = 3              输出:                
          3                            3
         / \                          /
        0   4                        2 
         \                          /
          2                        1 
         /
        1
```

# 路径问题
## 1 路径总和I
112\. Path Sum

[力扣](https://leetcode-cn.com/problems/path-sum/) / [Leetcode](https://leetcode.com/problems/path-sum/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L112.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L112.py)
```
题目：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
```

## 2 路径总和II 
113\. Path Sum II

[力扣](https://leetcode-cn.com/problems/path-sum-ii/) / [Leetcode](https://leetcode.com/problems/path-sum-ii/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L113-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L113-m.py)
```
题目:给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。
示例:
给定如下二叉树，以及目标和 sum = 22，               返回:

              5                                [
             / \                                 [5,4,11,2],
            4   8                                [5,8,4,5]
           /   / \                             ]
          11  13  4
         /  \    / \
        7    2  5   1
```

## 3 二叉树中的最大路径和
124\. Binary Tree Maximum Path Sum (hard)

[力扣](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) / [Leetcode](https://leetcode.com/problems/binary-tree-maximum-path-sum/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L124-h.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L124-h.py)
```
题目:给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，
    达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
```

## 4 二叉树的所有路径
257\. Binary Tree Paths

[力扣](https://leetcode-cn.com/problems/binary-tree-paths/) / [Leetcode](https://leetcode.com/problems/binary-tree-paths/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L257.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L257.py)
```
题目:给定一个二叉树，返回所有从根节点到叶子节点的路径。
```

## 5 统计左叶子节点的和
404\. Sum of Left Leaves

[力扣](https://leetcode-cn.com/problems/sum-of-left-leaves/) / [Leetcode](https://leetcode.com/problems/sum-of-left-leaves/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L404.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L404.py)
```
题目:计算给定二叉树的所有左叶子之和。
```

## 6 路径总和III
437\. Path Sum III

[力扣](https://leetcode-cn.com/problems/path-sum-iii/) / [Leetcode](https://leetcode.com/problems/path-sum-iii/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L437.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L437.py)
```
题目:给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。
    路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
    二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。
```

## 7 间隔遍历
337\. House Robber III 

[力扣](https://leetcode-cn.com/problems/house-robber-iii/) / [Leetcode](https://leetcode.com/problems/house-robber-iii/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L337-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_4_path_recurrent/L337-m.py)
```
题目：抢劫根形分布的社区，不得同时抢劫有直接连接的2个房子，求最大可抢劫量。

         示例 1:
         输入: [3,2,3,null,3,null,1]

              3
             / \
            2   3
             \   \ 
              3   1

         输出: 7 
         解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

         示例 2:
         输入: [3,4,5,1,3,null,1]

              3
             / \
            4   5
           / \   \ 
          1   3   1

         输出: 9
         解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```


# 树的遍历
## 1 前序遍历
144\. Binary Tree Preorder Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-preorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L144-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L144-m.py)

## 2 后序遍历
145\. Binary Tree Postorder Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-postorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L145-h.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L145-h.py)

## 3 中序遍历
94\. Binary Tree Inorder Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-inorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L94-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L94-m.py)

## 4 层序遍历
102\. Binary Tree Level Order Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-level-order-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L102-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L102-m.py)

## 5 之字形遍历
103\. Binary Tree Zigzag Level Order Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L103-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L103-m.py)
```
题目:给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
给定二叉树 [3,9,20,null,null,15,7],                 返回锯齿形层次遍历如下：

    3                                             [
   / \                                              [3],
  9  20                                             [20,9],
    /  \                                            [15,7]
   15   7                                         ]
```

## 6 填充每个节点的下一个右侧节点指针
116\. Populating Next Right Pointers in Each Node

[力扣](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/) / [Leetcode](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/) / [Cpp](../ds_5_tree/tree_2_traversal/L116-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L116-m.py)
```
题目:给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
```

## 7 一棵树每层节点的平均数
637\. Average of Levels in Binary Tree

[力扣](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/) / [Leetcode](https://leetcode.com/problems/average-of-levels-in-binary-tree/) / [Cpp](../ds_5_tree/tree_2_traversal/L637.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L637.py)
```
题目:给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
```

## 8 得到左下角的节点
513\. Find Bottom Left Tree Value

[力扣](https://leetcode-cn.com/problems/find-bottom-left-tree-value/) / [Leetcode](https://leetcode.com/problems/find-bottom-left-tree-value/) / [Cpp](../ds_5_tree/tree_2_traversal/L513-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L513-m.py)
```
题目:给定一个二叉树，在树的最后一行找到最左边的值。
```

## 9 二叉树的序列化与反序列化
297\. Serialize and Deserialize Binary Tree

[力扣](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) / [Leetcode](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) / [Cpp](../ds_5_tree/tree_2_traversal/L297-h.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L297-h.py)
```
题目:序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，
    同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
    请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证
    一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

示例: 
         你可以将以下二叉树：

             1
            / \
           2   3
              / \
             4   5

         序列化为 "[1,2,3,null,null,4,5]"
提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。
```

## 10 N叉树的前序遍历
589\. N-ary Tree Preorder Traversal

[力扣](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/) / [Leetcode](https://leetcode.com/problems/n-ary-tree-preorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L589.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L589.py)


## 11 N叉树的后序遍历
590\. N-ary Tree Postorder Traversal

[力扣](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/) / [Leetcode](https://leetcode.com/problems/n-ary-tree-postorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L590.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L590.py)

## 12 N叉树的层序遍历
429\. N-ary Tree Level Order Traversal

[力扣](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/) / [Leetcode](https://leetcode.com/problems/n-ary-tree-level-order-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L429-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_2_traversal/L429-m.py)


# 二叉搜索树特性
## 1 验证二叉搜索树 
98\. Validate Binary Search Tree

[力扣](https://leetcode-cn.com/problems/validate-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/validate-binary-search-tree/) / [Cpp](../ds_5_tree/tree_3_bst_property/L98-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L98-m.py)
```
题目:给定一个二叉树，判断其是否是一个有效的二叉搜索树。
    假设一个二叉搜索树具有如下特征：
      节点的左子树只包含小于当前节点的数。
      节点的右子树只包含大于当前节点的数。
      所有左子树和右子树自身必须也是二叉搜索树。
```

## 2 二叉搜索树中的第K小元素
230\. Kth Smallest Element in a BST

[力扣](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/) / [Leetcode](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) / [Cpp](../ds_5_tree/tree_3_bst_property/L230-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L230-m.py)

## 3 寻找二叉查找树中出现次数最多的值
501\. Find Mode in Binary Search Tree

[力扣](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/find-mode-in-binary-search-tree/) / [Cpp](../ds_5_tree/tree_3_bst_property/L501.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L501.py)
```
题目:给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
    假定 BST 有如下定义：
      1 结点左子树中所含结点的值小于等于当前结点的值
      2 结点右子树中所含结点的值大于等于当前结点的值
      3 左子树和右子树都是二叉搜索树
提示：如果众数超过1个，不需考虑输出顺序
进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）
```

## 4 在二叉查找树中查找两个节点之差的最小绝对值
530\. Minimum Absolute Difference in BST

[力扣](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/) / [Leetcode](https://leetcode.com/problems/minimum-absolute-difference-in-bst/) / [Cpp](../ds_5_tree/tree_3_bst_property/L530.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L530.py)

## 5 把二叉搜索树转换为累加树
538\. Convert BST to Greater Tree

[力扣](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/) / [Leetcode](https://leetcode.com/problems/convert-bst-to-greater-tree/) / [Cpp](../ds_5_tree/tree_3_bst_property/L538.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L538.py)
```
题目：给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），
     使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
```

## 6 在二叉查找树中寻找两个节点，使它们的和为一个定值
653\. Two Sum IV - Input is a BST

[力扣](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/) / [Leetcode](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) / [Cpp](../ds_5_tree/tree_3_bst_property/L653.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_3_bst_property/L653.py)
```
题目:给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。
```

# 树的构建
## 1 从前序与中序遍历序列构造二叉树
105\. Construct Binary Tree from Preorder and Inorder Traversal

[力扣](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) / [Leetcode](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) / [Cpp](../ds_5_tree/tree_4_build_tree/L105-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L105-m.py)
```
你可以假设树中没有重复的元素。例如，给出

      前序遍历 preorder = [3,9,20,15,7]
      中序遍历 inorder = [9,3,15,20,7]
      
返回如下的二叉树：
          3
         / \
        9  20
          /  \
         15   7
```

## 2 从中序与后序遍历序列构造二叉树
106\. Construct Binary Tree from Inorder and Postorder Traversal

[力扣](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) / [Leetcode](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) / [Cpp](../ds_5_tree/tree_4_build_tree/L106-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L106-m.py)
```
你可以假设树中没有重复的元素。例如，给出

      中序遍历 inorder = [9,3,15,20,7]
      后序遍历 postorder = [9,15,7,20,3]
      
返回如下的二叉树：
       3
      / \
     9  20
       /  \
      15   7
```

## 3 不同的二叉搜索树II
95\. Unique Binary Search Trees II

[力扣](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) / [Leetcode](https://leetcode.com/problems/unique-binary-search-trees-ii/) /  [Cpp](../ds_5_tree/tree_4_build_tree/L95-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L95-m.py)
```
题目:给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。
```

## 4 将有序数组转换为二叉搜索树
108\. Convert Sorted Array to Binary Search Tree

[力扣](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) / [Cpp](../ds_5_tree/tree_4_build_tree/L108.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L108.py)
```
题目:将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。
    本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
    给定有序数组: [-10,-3,0,5,9],
    一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

            0
           / \
         -3   9
         /   /
       -10  5
```

## 5 根据有序链表构造平衡的二叉查找树
109\. Convert Sorted List to Binary Search Tree

[力扣](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/) / [Cpp](../ds_5_tree/tree_4_build_tree/L109-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_4_build_tree/L109-m.py)
```
题目:给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
    本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
示例:
    给定的有序链表： [-10, -3, 0, 5, 9],
    一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

            0
           / \
         -3   9
         /   /
       -10  5
```


# 树和链表  
## 1 二叉树展开为链表  
114\. Flatten Binary Tree to Linked List

[力扣](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/) / [Leetcode](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/) / [Cpp](../ds_5_tree/tree_5_tree_and_linkedlist/L114-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_5_tree_and_linkedlist/L114-m.py)
```
题目:给定一个二叉树，原地将它展开为一个单链表。
    例如，给定二叉树
                1
               / \
              2   5
             / \   \
            3   4   6
将其展开为：
               1
                \
                 2
                  \
                   3
                    \
                     4
                      \
                       5
                        \
                         6
```

## 2 二叉搜索树与双向循环链表
剑指offer36 leetcode426(锁)

[力扣](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) / [Cpp](../ds_5_tree/tree_5_tree_and_linkedlist/J36-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_5_tree_and_linkedlist/J36-m.py)
```
题目:输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
```

# 字典树
## 1 设计字典树
208\. Implement Trie (Prefix Tree)

[力扣](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) / [Leetcode](https://leetcode.com/problems/implement-trie-prefix-tree/) / [Cpp](../ds_5_tree/tree_6_trie_tree/L208-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_6_trie_tree/L208-m.py)
```
题目:实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。

示例:
      Trie trie = new Trie();

      trie.insert("apple");
      trie.search("apple");   // 返回 true
      trie.search("app");     // 返回 false
      trie.startsWith("app"); // 返回 true
      trie.insert("app");   
      trie.search("app");     // 返回 true
说明:
      你可以假设所有的输入都是由小写字母 a-z 构成的。
      保证所有输入均为非空字符串。
```

## 2 实现一个Trie用来求前缀和
677\. Map Sum Pairs

[力扣](https://leetcode-cn.com/problems/map-sum-pairs/) / [Leetcode](https://leetcode.com/problems/map-sum-pairs/) / [Cpp](../ds_5_tree/tree_6_trie_tree/L677-m.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_6_trie_tree/L677-m.py)
```
实现一个 MapSum 类里的两个方法，insert 和 sum。
对于方法 insert，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。
对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。

示例 1:
      输入: insert("apple", 3), 输出: Null
      输入: sum("ap"), 输出: 3
      输入: insert("app", 2), 输出: Null
      输入: sum("ap"), 输出: 5
```

