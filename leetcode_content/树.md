<!-- GFM-TOC -->
* [递归-布尔](#递归返回布尔)
    * [1. 对称二叉树](#1-对称二叉树)
    * [2. 另一个树的子树](#2-另一个树的子树) 
    
* [递归-整数](#递归返回整数)
    * [1. 二叉树的最大深度](#1-二叉树的最大深度)
    * [2. 二叉树的最小深度](#2-二叉树的最小深度)
    * [3. 平衡二叉树](#3-平衡二叉树)
    * [4. 二叉树的直径](#4-二叉树的直径)
    * [5. 相同节点值的最大路径长度](#5-相同节点值的最大路径长度)
    * [6. N叉树的最大深度](#6-N叉树的最大深度)
    
* [递归-树节点](#递归返回树节点)
    * [1. 翻转二叉树](#1-翻转二叉树)
    * [2. 二叉搜索树的最近公共祖先](#2-二叉搜索树的最近公共祖先)
    * [3. 二叉树的最近公共祖先](#3-二叉树的最近公共祖先)
    * [4. 合并二叉树](#4-合并二叉树)
    * [5. 找出二叉树中第二小的节点](#5-找出二叉树中第二小的节点)
    * [6. 修剪二叉查找树](#6-修剪二叉查找树) 
    
* [递归-路径问题](#路径问题)
    * [1. 路径总和I](#1-路径总和I)
    * [2. 路径总和II](#2-路径总和II)
    * [3. 二叉树中的最大路径和](#3-二叉树中的最大路径和)
    * [4. 二叉树的所有路径](#4-二叉树的所有路径)
    * [5. 统计左叶子节点的和](#5-统计左叶子节点的和)
    * [6. 路径总和III](#6-路径总和III)
    * [7. 间隔遍历](#7-间隔遍历) 
    
* [树的遍历](#树的遍历)
    * [1. 前序遍历](#1-前序遍历)
    * [2. 后序遍历](#2-后序遍历)
    * [3. 中序遍历](#3-中序遍历)
    * [4. 层序遍历](#4-层序遍历)
    * [5. 之字形遍历](#5-之字形遍历)
    * [6. 填充每个节点的下一个右侧节点指针](#6-填充每个节点的下一个右侧节点指针)
    * [7. 一棵树每层节点的平均数](#7-一棵树每层节点的平均数)
    * [8. 得到左下角的节点](#8-得到左下角的节点)
    * [9. 二叉树的序列化与反序列化](#9-二叉树的序列化与反序列化)
    * [10. N叉树的前序遍历](#10-N叉树的前序遍历)
    * [11. N叉树的后序遍历](#11-N叉树的后序遍历)
    * [12. N叉树的层序遍历](#12-N叉树的层序遍历)  
    
* [二叉搜索树特性](#二叉搜索树特性)
    * [1. 验证二叉搜索树](#1-验证二叉搜索树)
    * [2. 二叉搜索树中的第K小元素](#2-二叉搜索树中的第K小元素)
    * [3. 寻找二叉查找树中出现次数最多的值](#3-寻找二叉查找树中出现次数最多的值)
    * [4. 在二叉查找树中查找两个节点之差的最小绝对值](#4-在二叉查找树中查找两个节点之差的最小绝对值)
    * [5. 把二叉搜索树转换为累加树](#5-把二叉搜索树转换为累加树)
    * [6. 组合总和](#6-组合总和)
    * [7. 在二叉查找树中寻找两个节点，使它们的和为一个定值](#7-在二叉查找树中寻找两个节点，使它们的和为一个定值)
    
* [树的构建](#树的构建)
    * [1. 从前序与中序遍历序列构造二叉树](#1-从前序与中序遍历序列构造二叉树)
    * [2. 从中序与后序遍历序列构造二叉树](#2-从中序与后序遍历序列构造二叉树)
    * [3. 不同的二叉搜索树II](#3-不同的二叉搜索树II)
    * [4. 将有序数组转换为二叉搜索树](#4-将有序数组转换为二叉搜索树)
    * [5. 根据有序链表构造平衡的二叉查找树](#5-根据有序链表构造平衡的二叉查找树)

* [树和链表](#树和链表)
   * [1. 二叉树展开为链表](#1-二叉树展开为链表)
   * [2. 二叉搜索树与双向循环链表](#2-二叉搜索树与双向循环链表)
   
* [字典树](#字典树)
    * [1. 设计字典树](#1-设计字典树)
    * [2. 实现一个Trie用来求前缀和](#2-实现一个Trie用来求前缀和)
<!-- GFM-TOC -->

Python二叉树表达:
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
```

# 递归返回布尔
## 1 对称二叉树     
101\. Symmetric Tree

[力扣](https://leetcode-cn.com/problems/symmetric-tree/) / [Leetcode](https://leetcode.com/problems/symmetric-tree/) / [Cpp](../ds_5_tree/tree_1_1_bool_recurrent/L101.cpp) / [Python3](../python-algorithm/ds_5_tree/tree_1_1_bool_recurrent/L101.py)
```
题目:给定一个二叉树，检查它是否是镜像对称的。
```

## 2 另一个树的子树
572\. Subtree of Another Tree

[力扣](https://leetcode-cn.com/problems/subtree-of-another-tree/) / [Leetcode](https://leetcode.com/problems/subtree-of-another-tree/) / [Cpp](../ds_5_tree/tree_1_1_bool_recurrent/L572.cpp)
```
题目:给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 
    的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
```

# 递归返回整数
## 1 二叉树的最大深度
104\. Maximum Depth of Binary Tree

[力扣](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) / [Leetcode](https://leetcode.com/problems/maximum-depth-of-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L104.cpp)
```
题目:给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
```

## 2 二叉树的最小深度
111\. Minimum Depth of Binary Tree

[力扣](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) / [Leetcode](https://leetcode.com/problems/minimum-depth-of-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L111.cpp)
```
题目:给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
```

## 3 平衡二叉树
110\. Balanced Binary Tree

[力扣](https://leetcode-cn.com/problems/balanced-binary-tree/) / [Leetcode](https://leetcode.com/balanced-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L110.cpp)
```
题目:给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。
```

## 4 二叉树的直径
543\. Diameter of Binary Tree

[力扣](https://leetcode-cn.com/problems/diameter-of-binary-tree/) / [Leetcode](https://leetcode.com/problems/diameter-of-binary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L543.cpp)
```
题目:给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```

## 5 相同节点值的最大路径长度
687\. Longest Univalue Path

[力扣](https://leetcode-cn.com/problems/longest-univalue-path/) / [Leetcode](https://leetcode.com/problems/longest-univalue-path/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L687.cpp)
```
题目:给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。
注意：两个节点之间的路径长度由它们之间的边数表示。
输入:

              1
             / \
            4   5
           / \   \
          4   4   5

输出：2
```

## 6 N叉树的最大深度
559\. Maximum Depth of N-ary Tree

[力扣](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/) / [Leetcode](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/) / [Cpp](../ds_5_tree/tree_1_2_inter_recurrent/L559.cpp)
```
题目:给定一个 N 叉树，找到其最大深度。
    最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
```


# 递归返回树节点
## 1 翻转二叉树
226\. Invert Binary Tree

[力扣](https://leetcode-cn.com/problems/invert-binary-tree/) / [Leetcode](https://leetcode.com/problems/invert-binary-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L226.cpp)
```
题目:翻转一棵二叉树。
输入：               输出：    

     4                   4
   /   \               /   \
  2     7             7     2
 / \   / \           / \   / \
1   3 6   9         1   3 6   9
```

## 2 二叉搜索树的最近公共祖先
235\. Lowest Common Ancestor of a Binary Search Tree

[力扣](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L235.cpp)
```
题目:给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
    百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
    满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```

## 3 二叉树的最近公共祖先
236\. Lowest Common Ancestor of a Binary Tree

[力扣](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) / [Leetcode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L236-m.cpp)
```
题目:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
    百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
    满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```

## 4 合并二叉树
617\. Merge Two Binary Trees

[力扣](https://leetcode-cn.com/problems/merge-two-binary-trees/) / [Leetcode](https://leetcode.com/problems/merge-two-binary-trees/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L617.cpp)
```
      输入: 
         Tree 1                     Tree 2                  
                1                         2                             
               / \                       / \                            
              3   2                     1   3                        
             /                           \   \                      
            5                             4   7                  
      输出: 
      合并后的树:
              3
             / \
            4   5
           / \   \ 
          5   4   7
```

## 5 找出二叉树中第二小的节点
671\. Second Minimum Node In a Binary Tree

[力扣](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/) / [Leetcode](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L671.cpp)
```
题目:给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，
    那么该节点的值等于两个子节点中较小的一个。
    给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1:
      输入: 
          2
         / \
        2   5
           / \
          5   7
      输出: 5
      说明: 最小的值是 2 ，第二小的值是 5 。
```

## 6 修剪二叉查找树
669\. Trim a Binary Search Tree

[力扣](https://leetcode-cn.com/problems/trim-a-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/trim-a-binary-search-tree/) / [Cpp](../ds_5_tree/tree_1_3_node_recurrent/L669.cpp)
```
题目：给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。
     你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。
     
      输入:  L = 1  R = 3              输出:                
          3                            3
         / \                          /
        0   4                        2 
         \                          /
          2                        1 
         /
        1
```

# 路径问题
## 1 路径总和I
112\. Path Sum

[力扣](https://leetcode-cn.com/problems/path-sum/) / [Leetcode](https://leetcode.com/problems/path-sum/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L112.cpp)

## 2 路径总和II 
113\. Path Sum II

[力扣](https://leetcode-cn.com/problems/path-sum-ii/) / [Leetcode](https://leetcode.com/problems/path-sum-ii/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L113-m.cpp)

## 3 二叉树中的最大路径和
124\. Binary Tree Maximum Path Sum

[力扣](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) / [Leetcode](https://leetcode.com/problems/binary-tree-maximum-path-sum/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L124-h.cpp)

## 4 二叉树的所有路径
257\. Binary Tree Paths

[力扣](https://leetcode-cn.com/problems/binary-tree-paths/) / [Leetcode](https://leetcode.com/problems/binary-tree-paths/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L257.cpp)

## 5 统计左叶子节点的和
404\. Sum of Left Leaves

[力扣](https://leetcode-cn.com/problems/sum-of-left-leaves/) / [Leetcode](https://leetcode.com/problems/sum-of-left-leaves/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L404.cpp)

## 6 路径总和III
437\. Path Sum III

[力扣](https://leetcode-cn.com/problems/path-sum-iii/) / [Leetcode](https://leetcode.com/problems/path-sum-iii/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L437.cpp)

## 7 间隔遍历
337\. House Robber III 

[力扣](https://leetcode-cn.com/problems/house-robber-iii/) / [Leetcode](https://leetcode.com/problems/house-robber-iii/) / [Cpp](../ds_5_tree/tree_1_4_path_recurrent/L337-m.cpp)



# 树的遍历
## 1 前序遍历
144\. Binary Tree Preorder Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-preorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L144-m.cpp)

## 2 后序遍历
145\. Binary Tree Postorder Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-postorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L145-h.cpp)

## 3 中序遍历
94\. Binary Tree Inorder Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-inorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L94-m.cpp)

## 4 层序遍历
102\. Binary Tree Level Order Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-level-order-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L102-m.cpp)

## 5 之字形遍历
103\. Binary Tree Zigzag Level Order Traversal

[力扣](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) / [Leetcode](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L103-m.cpp)

## 6 填充每个节点的下一个右侧节点指针
116\. Populating Next Right Pointers in Each Node

[力扣](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/) / [Leetcode](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/) / [Cpp](../ds_5_tree/tree_2_traversal/L116-m.cpp)

## 7 一棵树每层节点的平均数
637\. Average of Levels in Binary Tree

[力扣](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/) / [Leetcode](https://leetcode.com/problems/average-of-levels-in-binary-tree/) / [Cpp](../ds_5_tree/tree_2_traversal/L637.cpp)

## 8 得到左下角的节点
513\. Find Bottom Left Tree Value

[力扣](https://leetcode-cn.com/problems/find-bottom-left-tree-value/) / [Leetcode](https://leetcode.com/problems/find-bottom-left-tree-value/) / [Cpp](../ds_5_tree/tree_2_traversal/L513-m.cpp)

## 9 二叉树的序列化与反序列化
297\. Serialize and Deserialize Binary Tree

[力扣](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) / [Leetcode](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) / [Cpp](../ds_5_tree/tree_2_traversal/L297-h.cpp)

## 10 N叉树的前序遍历
589\. N-ary Tree Preorder Traversal

[力扣](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/) / [Leetcode](https://leetcode.com/problems/n-ary-tree-preorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L589.cpp)


## 11 N叉树的后序遍历
590\. N-ary Tree Postorder Traversal

[力扣](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/) / [Leetcode](https://leetcode.com/problems/n-ary-tree-postorder-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L590.cpp)

## 12 N叉树的层序遍历
429\. N-ary Tree Level Order Traversal

[力扣](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/) / [Leetcode](https://leetcode.com/problems/n-ary-tree-level-order-traversal/) / [Cpp](../ds_5_tree/tree_2_traversal/L429-m.cpp)


# 二叉搜索树特性
## 1 验证二叉搜索树 
98\. Validate Binary Search Tree

[力扣](https://leetcode-cn.com/problems/validate-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/validate-binary-search-tree/) / [Cpp](../ds_5_tree/tree_3_bst_property/L98-m.cpp)

## 2 二叉搜索树中的第K小元素
230\. Kth Smallest Element in a BST

[力扣](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/) / [Leetcode](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) / [Cpp](../ds_5_tree/tree_3_bst_property/L230-m.cpp)

## 3 寻找二叉查找树中出现次数最多的值
501\. Find Mode in Binary Search Tree

[力扣](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/find-mode-in-binary-search-tree/) / [Cpp](../ds_5_tree/tree_3_bst_property/L501.cpp)

## 4 在二叉查找树中查找两个节点之差的最小绝对值
530\. Minimum Absolute Difference in BST

[力扣](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/) / [Leetcode](https://leetcode.com/problems/minimum-absolute-difference-in-bst/) / [Cpp](../ds_5_tree/tree_3_bst_property/L530.cpp)

## 5 把二叉搜索树转换为累加树
538\. Convert BST to Greater Tree

[力扣](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/) / [Leetcode](https://leetcode.com/problems/convert-bst-to-greater-tree/) / [Cpp](../ds_5_tree/tree_3_bst_property/L538.cpp)

## 6 在二叉查找树中寻找两个节点，使它们的和为一个定值
653\. Two Sum IV - Input is a BST

[力扣](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/) / [Leetcode](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) / [Cpp](../ds_5_tree/tree_3_bst_property/L653.cpp)


# 树的构建
## 1 从前序与中序遍历序列构造二叉树
105\. Construct Binary Tree from Preorder and Inorder Traversal

[力扣](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) / [Leetcode](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) / [Cpp](../ds_5_tree/tree_4_build_tree/L105-m.cpp)

## 2 从中序与后序遍历序列构造二叉树
106\. Construct Binary Tree from Inorder and Postorder Traversal

[力扣](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) / [Leetcode](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) / [Cpp](../ds_5_tree/tree_4_build_tree/L106-m.cpp)

## 3 不同的二叉搜索树II
95\. Unique Binary Search Trees II

[力扣](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) / [Leetcode](https://leetcode.com/problems/unique-binary-search-trees-ii/) /  [Cpp](../ds_5_tree/tree_4_build_tree/L95-m.cpp)

## 4 将有序数组转换为二叉搜索树
108\. Convert Sorted Array to Binary Search Tree

[力扣](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) / [Cpp](../ds_5_tree/tree_4_build_tree/L108.cpp)

## 5 根据有序链表构造平衡的二叉查找树
109\. Convert Sorted List to Binary Search Tree

[力扣](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/) / [Leetcode](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/) / [Cpp](../ds_5_tree/tree_4_build_tree/L109-m.cpp)


# 树和链表  
## 1 二叉树展开为链表  
114\. Flatten Binary Tree to Linked List

[力扣](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/) / [Leetcode](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/) / [Cpp](../ds_5_tree/tree_5_tree_and_linkedlist/L114-m.cpp)

## 2 二叉搜索树与双向循环链表
剑指offer36 leetcode426(锁)

[力扣](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) / [Cpp](../ds_5_tree/tree_5_tree_and_linkedlist/J36-m.cpp)

# 字典树
## 1 设计字典树
208\. Implement Trie (Prefix Tree)

[力扣](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) / [Leetcode](https://leetcode.com/problems/implement-trie-prefix-tree/) / [Cpp](../ds_5_tree/tree_6_trie_tree/L208-m.cpp)

## 2 实现一个Trie用来求前缀和
677\. Map Sum Pairs

[力扣](https://leetcode-cn.com/problems/map-sum-pairs/) / [Leetcode](https://leetcode.com/problems/map-sum-pairs/) / [Cpp](../ds_5_tree/tree_6_trie_tree/L677-m.cpp)


