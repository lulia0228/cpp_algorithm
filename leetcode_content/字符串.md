<!-- GFM-TOC -->
* [回文串](#回文串)
    * [1. 回文子串](#1-回文子串)
    * [2. 验证回文串](#2-验证回文串)
    * [3. 验证回文字符串Ⅱ](#3-验证回文字符串Ⅱ)

* [字符串运算](#字符串运算)
    * [1. 字符串相加](#1-字符串相加)
    * [2. 字符串相乘](#2-字符串相乘)
    * [3. 比较版本号](#3-比较版本号)
    * [4. 重复的子字符串](#4-重复的子字符串)

* [一般问题](#一般问题)
    * [1. 字符串转整数](#1-字符串转整数--有限状态机)
    * [2. 压缩字符串](#2-压缩字符串)
    * [3. 比较版本号](#3-比较版本号)
    * [4. 重复的子字符串](#4-重复的子字符串)
    * [5. 最长重复子串](#5-最长重复子串)
    * [6. 最长公共前缀](#6-最长公共前缀)
    * [7. 字符串同构](#7-字符串同构)
    * [8. 统计二进制字符串中连续1和连续0数量相同的子字符串个数](#8-统计二进制字符串中连续1和连续0数量相同的子字符串个数)

<!-- GFM-TOC -->

# 回文串
## 1 回文子串
647\. Palindromic Substrings    

[力扣](https://leetcode-cn.com/problems/palindromic-substrings/) / [Leetcode](https://leetcode.com/problems/palindromic-substrings/) / [Cpp](../ds_6_string/palindrome_string/L647-m.cpp) / [Python3](../python-algorithm/ds_6_string/palindrome_string/L647-m.py)
```
题目：给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
     具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例：
      输入："aaa"
      输出：6
      解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

## 2 验证回文串
125\. Valid Palindrome

[力扣](https://leetcode-cn.com/problems/valid-palindrome/) / [Leetcode](https://leetcode.com/problems/valid-palindrome/) / [Cpp](../algo_03_two_points/L125.cpp) / [Python3](../python-algorithm/ds_6_string/palindrome_string/L125.py)


## 3 验证回文字符串Ⅱ
680\. Valid Palindrome II

[力扣](https://leetcode-cn.com/problems/valid-palindrome-ii/) / [Leetcode](https://leetcode.com/problems/valid-palindrome-ii/) / [Cpp](../algo_03_two_points/L680.cpp) / [Python3](../python-algorithm/ds_6_string/palindrome_string/L680.py)


# 字符串运算
## 1 字符串相加
415\. Add Strings

[力扣](https://leetcode-cn.com/problems/add-strings/) / [Leetcode](https://leetcode.com/problems/add-strings/) / [Cpp](../algo_09_math/L415.cpp) / [Python3](../python-algorithm/ds_6_string/math/L415.py)
```
题目：给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。
提示：
      num1 和num2 的长度都小于 5100
      num1 和num2 都只包含数字 0-9
      num1 和num2 都不包含任何前导零
      你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式
```

## 2 字符串相乘
43\. Multiply Strings

[力扣](https://leetcode-cn.com/problems/multiply-strings/) / [Leetcode](https://leetcode.com/problems/multiply-strings/) / [Cpp](../algo_09_math/L43.cpp) / [Python3](../python-algorithm/ds_6_string/math/L43.py)
```
题目：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。不得转化成整数进行。
```

## 3 二进制求和
67\. Add Binary

[力扣](https://leetcode-cn.com/problems/add-binary/) / [Leetcode](https://leetcode.com/problems/add-binary/) / [Cpp](../algo_09_math/L67.cpp) / [Python3](../python-algorithm/ds_6_string/math/L67.py)
```
题目：给你两个二进制字符串，返回它们的和（用二进制表示）。
      输入为 非空 字符串且只包含数字 1 和 0。
```

## 4 字符串相减
000\.  字符串相减

[codetop](https://mp.weixin.qq.com/s?__biz=MzkxNDI1MTA1MA==&mid=2247484424&idx=1&sn=be2a24dcce2996c34e12ab36f21e80f4&source=41#wechat_redirect) / [Python3](../python-algorithm/ds_6_string/math/b字符串相减.py)
```
题目：给定两个字符串形式的非负整数 num1 和num2 ，计算它们的差。
注意：
      num1 和num2 都只会包含数字 0-9
      num1 和num2 都不包含任何前导零
      你不能使用任何內建 BigInteger 库
```

## 5 36进制加法
000\.  36进制加法

[codetop](https://mp.weixin.qq.com/s?__biz=MzkxNDI1MTA1MA==&mid=2247484413&idx=1&sn=8bf537e8c4887fee70ecb8650c25373e&source=41#wechat_redirect)  / [Python3](../python-algorithm/ds_6_string/math/b36进制加法.py)
```
题目：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。不得转化成整数进行。
```

## 6 36进制减法
000\.  36进制减法

[codetop](https://mp.weixin.qq.com/s?__biz=MzkxNDI1MTA1MA==&mid=2247484426&idx=1&sn=640a03287eb3f68469cda15c2e4a4278&source=41#wechat_redirect)  / [Python3](../python-algorithm/ds_6_string/math/b36进制减法.py)
```
题目：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。不得转化成整数进行。
```


# 一般问题
## 1 字符串转整数--有限状态机
8\. String to Integer (stoi)

[力扣](https://leetcode-cn.com/problems/string-to-integer-atoi/) / [Leetcode](https://leetcode.com/problems/string-to-integer-atoi/) / [Cpp](../ds_6_string/L8.cpp) / [Python3](../python-algorithm/ds_6_string/L8-m.py)
```
思路：有限转状态机。
```
## 2 压缩字符串
443. String Compression
三指针解决   

[力扣](https://leetcode-cn.com/problems/string-compression/) / [Leetcode](https://leetcode.com/problems/string-compression/) / [Cpp](../ds_6_string/L443-m.cpp) / [Python3](../python-algorithm/ds_6_string/L443-m.py)
```
题目：给定一组字符，使用原地算法将其压缩。
      压缩后的长度必须始终小于或等于原数组长度。
      数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。
      在完成原地修改输入数组后，返回数组的新长度。
进阶：
      你能否仅使用O(1) 空间解决问题？
示例 1：
   输入：["a","a","b","b","c","c","c"]
   输出：返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
   说明："aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。
```

## 3 比较版本号
165\. Compare Version Numbers

[力扣](https://leetcode-cn.com/problems/compare-version-numbers/) / [Leetcode](https://leetcode.com/problems/compare-version-numbers/) / [Cpp](../ds_6_string/L165-m.cpp) / [Python3](../python-algorithm/ds_6_string/L165-m.py)
```
题目：给你两个版本号 version1 和 version2 ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。
每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，
下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，
只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。
如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。
例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，
而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。

返回规则如下：
   如果 version1 > version2 返回 1，
   如果 version1 < version2 返回 -1，
   除此之外返回 0。

输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"

```

## 4 重复的子字符串
459\. Repeated Substring Pattern

[力扣](https://leetcode-cn.com/problems/repeated-substring-pattern/) / [Leetcode](https://leetcode.com/problems/repeated-substring-pattern/) / [Cpp](../ds_6_string/L459.cpp) / [Python3](../python-algorithm/ds_6_string/L459.py)
```
题目：给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。
      给定的字符串只含有小写英文字母，并且长度不超过10000。
```

## 5 最长重复子串
NC142\. 最长重复子串

[牛客](https://www.nowcoder.com/practice/4fe306a84f084c249e4afad5edf889cc?tpId=188&&tqId=38654&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)  / [Python3](../python-algorithm/ds_6_string/NC142最长重复子串.py)
```
题目：一个重复字符串是由两个相同的字符串首尾拼接而成，例如abcabc便是长度为6的一个重复字符串，而abcba则不存在重复字符串。
     给定一个字符串，请编写一个函数，返回其最长的重复字符子串。
     若不存在任何重复字符子串，则返回0。
示例 1 :
     输入: "ababc"
     输出: 4
     解释: abab为最长的重复字符子串，长度为4 
```

## 6 最长公共前缀
14\. Longest Common Prefix

[力扣](https://leetcode-cn.com/problems/longest-common-prefix/) / [Leetcode](https://leetcode.com/problems/longest-common-prefix/) / [Cpp](../ds_6_string/L14.cpp) / [Python3](../python-algorithm/ds_6_string/L14.py)
```
题目：编写一个函数来查找字符串数组中的最长公共前缀。不存在返回：“”。
思路：(1)纵向对比每个字符串（2）字典树 （3）python特殊技巧字符串排序
```

## 7 字符串同构
205\. Isomorphic Strings

[力扣](https://leetcode-cn.com/problems/isomorphic-strings/) / [Leetcode](https://leetcode.com/problems/isomorphic-strings/) / [Cpp](../ds_6_string/L205.cpp) / [Python3](../python-algorithm/ds_6_string/L205.py)
```
题目：给定两个字符串 s 和 t，判断它们是否是同构的。如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。
     所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。
示例 1:
   输入: s = "egg", t = "add"
   输出: true
示例 2:
   输入: s = "foo", t = "bar"
   输出: false
```

## 8 统计二进制字符串中连续1和连续0数量相同的子字符串个数
696\. Count Binary Substrings

[力扣](https://leetcode-cn.com/problems/count-binary-substrings/) / [Leetcode](https://leetcode.com/problems/count-binary-substrings/) / [Cpp](../ds_6_string/L696.cpp) / [Python3](../python-algorithm/ds_6_string/L696.py)
```
题目：给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
     重复出现的子串要计算它们出现的次数。
示例 1 :
     输入: "00110011"
     输出: 6
     解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
     请注意，一些重复出现的子串要计算它们出现的次数。
     另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```
