<!-- GFM-TOC -->
* [一维公式递推](#一维公式递推)
    * [1. 爬楼梯](#1-爬楼梯)
    * [2. 母牛生产](#2-母牛生产)
    * [3. 变态跳](#3-变态跳)   
    
* [子序列问题](#子序列问题)
    * [1. 最长回文子串](#1-最长回文子串)
    * [2. 连续子数组：和最大](#2-最大连续子数组和)
    * [3. 连续子数组：乘积最大](#3-最大连续子数组乘积)
    * [4. 最长摆动子序列](#4-最长摆动子序列)
    * [5. 最长上升子序列](#5-最长上升子序列)
    * [6. 一组整数对能够构成的最长链](#6-一组整数对能够构成的最长链)
    * [7. 数组中等差递增子区间的个数](#7-数组中等差递增子区间的个数)
    * [8. 区域和检索-数组不可变](#8-区域和检索)
    
* [双序列问题](#双序列问题)
    * [1. 编辑距离](#1-编辑距离)
    * [2. 最长公共连续子数组](#2-最长公共连续子数组)
    * [3. 最长公共子序列](#3-最长公共子序列)
    * [4. 删除两个字符串的字符使它们相等](#4-删除两个字符串的字符使它们相等)
    
* [打家劫舍问题](#打家劫舍问题)
    * [1. 打家劫舍 ](#1-打家劫舍 )
    * [2. 打家劫舍II](#2-打家劫舍II)
    
* [0-1背包问题](#01背包问题)
    * [1. 目标和](#1-目标和)
    * [2. 分割等和子集](#2-分割等和子集)
    * [3. 一和零](#3-一和零)
    * [4. 单词拆分](#4-单词拆分)
    * [5. 零钱兑换](#5-零钱兑换)
    * [6. 组合总和](#6-组合总和)
    * [7. 找零钱的硬币数组合](#7-找零钱的硬币数组合)
    
* [特殊状态转移方程](#特殊状态转移方程)
    * [1. 格雷编码](#1-格雷编码)
    * [2. 比特位计数](#2-比特位计数)
    * [3. 解码方法](#3-解码方法)
    * [4. 复制粘贴字符](#4-复制粘贴字符)
    * [5. 整数拆分](#5-整数拆分)
    * [6. 整数拆分成最少平方数之和](#6-整数拆分成最少平方数之和)
    * [7. 不同的二叉搜索树  ](#7-不同的二叉搜索树) 
    
* [矩阵路径](#矩阵路径)
    * [1. 不同路径](#1-不同路径)
    * [2. 最小路径和](#2-最小路径和)
    
* [矩形问题](#矩形问题)
   * [1. 最大正方形](#1-最大正方形)
   * [2. 最大矩形](#2-最大矩形)
   
* [股票问题](#股票问题)
    * [1. 买卖股票一次交易](#1-买卖股票一次交易)
    * [2. 买卖股票不限次数](#2-买卖股票不限次数)
    * [3. 最佳买卖股票时机含冷冻期不限次数](#3-最佳买卖股票时机含冷冻期不限次数)
    * [4. 买卖股票的最佳时机含手续费不限次数](#4-买卖股票的最佳时机含手续费不限次数)
    * [5. 只能进行两次的股票交易](#5-只能进行两次的股票交易)
    * [6. 只能进行k次的股票交易](#6-只能进行k次的股票交易)

<!-- GFM-TOC -->
```
动态规划问题在于找出状态转移方程，此外，根据方程中所需要的上一个状态的变量情况，适当优化存储空间。
```

# 一维公式递推
## 1 爬楼梯    
70\. Climbing Stairs (Easy)

[力扣](https://leetcode-cn.com/problems/climbing-stairs/description/) / [Leetcode](https://leetcode.com/problems/climbing-stairs/description/) / [Cpp](../algo_05_dynamic_plan/dp_1_simple_recursion_formula/L70.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_1_simple_recursion_formula/L70.py)    

```
题目:假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
```

## 2 母牛生产
```
题目：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只成熟母牛，从第二年开始，
母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后母牛的数量。
 i >= 4 dp[i] = dp[i-1] + dp[i-3] 后一项代表的是当前年成熟的母牛的个数
```

## 3 变态跳    
```
题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。   
分析：因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级  
跳1级，剩下n-1级，则剩下跳法是f(n-1)
跳2级，剩下n-2级，则剩下跳法是f(n-2)

所以f(n) = f(n-1) + f(n-2) + ... + f(1)
因为f(n-1) = f(n-2) + f(n-3 )+ ... + f(1)
所以f(n) = 2 * f(n-1)。
根据f(1) = 1，f(n) = 2 * f(n-1)，可以得出f(n) = 2^(n-1)。
```

# 子序列问题
## 1 最长回文子串
5\. Longest Palindromic Substring

[力扣](https://leetcode-cn.com/problems/longest-palindromic-substring/) / [Leetcode](https://leetcode.com/problems/longest-palindromic-substring/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L5-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L5-m.py)   

## 2 最大连续子数组和
53\. Maximum Subarray

[力扣](https://leetcode-cn.com/problems/maximum-subarray/) / [Leetcode](https://leetcode.com/problems/maximum-subarray/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L53.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L53.py)   
```
题目:给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
```

## 3 最大连续子数组乘积
152\. Maximum Product Subarray

[力扣](https://leetcode-cn.com/problems/maximum-product-subarray/) / [Leetcode](https://leetcode.com/maximum-product-subarray/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L152-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L152-m.py)   
```
题目:给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
```

## 4 最长摆动子序列
376\. Wiggle Subsequence (Medium)

[力扣](https://leetcode-cn.com/problems/wiggle-subsequence/description/) / [Leetcode](https://leetcode.com/problems/wiggle-subsequence/description/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L376-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L376-m.py)   
```
题目：从给定数组中找到长度最长的摆动子序列。通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。
进阶:
     你能否用 O(n) 时间复杂度完成此题?
```


## 5 最长上升子序列
300\. Longest Increasing Subsequence (Medium)

[力扣](https://leetcode-cn.com/problems/longest-increasing-subsequence/description/) / [Leetcode](https://leetcode.com/problems/longest-increasing-subsequence/description/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L300.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L300.py)   
```
题目:给定一个无序的整数数组，找到其中最长上升子序列的长度。
示例:
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:
   可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
   你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
```

## 6 一组整数对能够构成的最长链
646\. Maximum Length of Pair Chain (Medium)

[力扣](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/description/) / [Leetcode](https://leetcode.com/problems/maximum-length-of-pair-chain/description/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L646-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L646-m.py)   
```
题目: 给出 n 个数对, 在每一个数对中，第一个数字总是比第二个数字小。
现在，我们定义一种跟随关系，当且仅当 b < c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。
给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。
示例 :
输入: [[1,2], [2,3], [3,4]]
输出: 2
解释: 最长的数对链是 [1,2] -> [3,4]
注意：给出数对的个数在 [1, 1000] 范围内。

```

## 7 数组中等差递增子区间的个数
413\. Arithmetic Slices (Medium)

[力扣](https://leetcode-cn.com/problems/arithmetic-slices/description/) / [Leetcode](https://leetcode.com/problems/arithmetic-slices/description/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L413-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L413-m.py)   
```
题目: 返回数组中是等差数列的连续子数组(长度至少为3)的个数。
```

## 8 区域和检索
303\. Range Sum Query - Immutable (Easy)

[力扣](https://leetcode-cn.com/problems/range-sum-query-immutable/description/) / [Leetcode](https://leetcode.com/problems/range-sum-query-immutable/description/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L303.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L303.py)   
```
题目:给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。
```

# 双序列问题
## 1 编辑距离
72\. Edit Distance (Hard)

[力扣](https://leetcode-cn.com/problems/edit-distance/description/) / [Leetcode](https://leetcode.com/problems/edit-distance/description/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L72-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L72-h.py)   
```
题目:给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
      插入一个字符
      删除一个字符
      替换一个字符
示例 1：
      输入：word1 = "horse", word2 = "ros"
      输出：3
      解释：
      horse -> rorse (将 'h' 替换为 'r')
      rorse -> rose (删除 'r')
      rose -> ros (删除 'e')
```

## 2 最长公共连续子数组
718\. Maximum Length of Repeated Subarray

[力扣](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/) / [Leetcode](https://leetcode.com/problems/maximum-length-of-repeated-subarray/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L718-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L718-m.py)   
```
题目: 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。
示例：
      输入：
      A: [1,2,3,2,1]
      B: [3,2,1,4,7]
      输出：3
      解释：
      长度最长的公共子数组是 [3, 2, 1] 。
```

## 3 最长公共子序列
1143\. Longest Common Subsequence

[力扣](https://leetcode-cn.com/problems/longest-common-subsequence/) / [Leetcode](https://leetcode.com/problems/longest-common-subsequence/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L1143-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L1143-m.py)   
```
题目：给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
     一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符
    （也可以不删除任何字符）后组成的新字符串。例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 
     的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
     若这两个字符串没有公共子序列，则返回 0。
```

## 4 删除两个字符串的字符使它们相等
583\. Delete Operation for Two Strings (Medium)

[力扣](https://leetcode-cn.com/problems/delete-operation-for-two-strings/description/) / [Leetcode](https://leetcode.com/problems/delete-operation-for-two-strings/description/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L583-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L583-m.py)   
```
题目:给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符
示例：
      输入: "sea", "eat"
      输出: 2
      解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

# 打家劫舍问题
## 1 打家劫舍
198\. House Robber (Easy)

[力扣](https://leetcode-cn.com/problems/house-robber/description/) / [Leetcode](https://leetcode.com/problems/house-robber/description/) / [Cpp](../algo_05_dynamic_plan/dp_5_rob/L198.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_5_rob/L198.py) 
```
题目: 一排房屋，给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置(不能偷2家挨着)
     的情况下 ，一夜之内能够偷窃到的最高金额。
```

## 2 打家劫舍II
213\. House Robber II (Medium)

[力扣](https://leetcode-cn.com/problems/house-robber-ii/description/) / [Leetcode](https://leetcode.com/problems/house-robber-ii/description/) / [Cpp](../algo_05_dynamic_plan/dp_5_rob/L213-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_5_rob/L213-m.py) 
```
题目：环形排列房屋，给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
```


# 01背包问题  
背包问题分类：     
（1）1维约束 ：原始背包问题就是1维约束问题，只有重量约束。      
（2）多维约束：背包问题里面除了有重量约束，再添加一个体积约束，就是二维约束问题。      
（3）完全背包：每个物品可以使用无限次     
（4）不完全背包：每个物品可使用的次数有限       

## 原始问题：      
现有n个物品，每个的重量用数组w表示，每个物品的价值用数组v表示，   
现在一个背包最大承重为C，求用这n个物品装入背包能获得的最大价值？   
```
class Solution:
    def knapsack(self, w , v , C ):
        n = len(w)
        # dp[i][j]表示用[0,...,i-1]物品填充容量为j的最大价值
        dp = [[0]*(C+1) for i in range(n+1)]
        for i in range(1, n):
            for j in range(C+1):
                # 装或者不装第i个
                if j >= w[i]:
                    dp[i][j] = max(dp[i-1][j], v[i-1]+dp[i-1][j - w[i-1]])
                else:
                    dp[i][j] = dp[i-1][j]  # 不装第i个
        return dp[n][C]
```

## 1 目标和
## 从非负整数数组中挑选出部分元素，使它们的和等于target，问有多少种挑选方法？
494\. Target Sum (Medium)

[力扣](https://leetcode-cn.com/problems/target-sum/description/) / [Leetcode](https://leetcode.com/problems/target-sum/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L494-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L494-m.py) 
```
题目: 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，
你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。
示例：
      输入：nums: [1, 1, 1, 1, 1], S: 3
      输出：5
      解释：
      -1+1+1+1+1 = 3
      +1-1+1+1+1 = 3
      +1+1-1+1+1 = 3
      +1+1+1-1+1 = 3
      +1+1+1+1-1 = 3
      一共有5种方法让最终目标和为3。
```

## 2 分割等和子集
## 判断是否可以从正整数数组中挑出部分元素，使他们的和为数组总和的一半。
416\. Partition Equal Subset Sum (Medium)

[力扣](https://leetcode-cn.com/problems/partition-equal-subset-sum/description/) / [Leetcode](https://leetcode.com/problems/partition-equal-subset-sum/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L416-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L416-m.py) 
```
题目: 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:
      每个数组中的元素不会超过 100
      数组的大小不会超过 200
示例 1:
      输入: [1, 5, 11, 5]
      输出: true
      解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

## 3 一和零
474\. Ones and Zeroes (Medium)

[力扣](https://leetcode-cn.com/problems/ones-and-zeroes/description/) / [Leetcode](https://leetcode.com/problems/ones-and-zeroes/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L474-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L474-m.py) 
```
题目: 在计算机界中，我们总是追求用有限的资源获取最大的收益。现在，假设你分别支配着 m 个 0 和 n 个 1。
     另外，还有一个仅包含 0 和 1 字符串的数组。你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出
     存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。
示例 1:
      输入: strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
      输出: 4
      解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。
      示例 2:

      输入: strs = ["10", "0", "1"], m = 1, n = 1
      输出: 2
      解释: 你可以拼出 "10"，但之后就没有剩余数字了。更好的选择是拼出 "0" 和 "1" 。
```

## 4 单词拆分
139\. Word Break (Medium)

[力扣](https://leetcode-cn.com/problems/word-break/description/) / [Leetcode](https://leetcode.com/problems/word-break/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L139-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L139-m.py) 
```
题目:给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
说明：
      拆分时可以重复使用字典中的单词。
      你可以假设字典中没有重复的单词。

示例 1：
      输入: s = "leetcode", wordDict = ["leet", "code"]
      输出: true
      解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：
      输入: s = "applepenapple", wordDict = ["apple", "pen"]
      输出: true
      解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
           注意你可以重复使用字典中的单词。
示例 3：
      输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
      输出: false
```

## 5 零钱兑换
322\. Coin Change (Medium)

[力扣](https://leetcode-cn.com/problems/coin-change/description/) / [Leetcode](https://leetcode.com/problems/coin-change/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L322-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L322-m.py) 
```
题目:给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
    如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。
示例 1：
      输入：coins = [1, 2, 5], amount = 11
      输出：3 
      解释：11 = 5 + 5 + 1
      示例 2：

      输入：coins = [2], amount = 3
      输出：-1
```

## 6 组合总和
377\. Combination Sum IV (Medium)

[力扣](https://leetcode-cn.com/problems/combination-sum-iv/description/) / [Leetcode](https://leetcode.com/problems/combination-sum-iv/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L377-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L377-m.py) 
```
题目: 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。
示例:
      nums = [1, 2, 3]
      target = 4
      所有可能的组合为：
      (1, 1, 1, 1)
      (1, 1, 2)
      (1, 2, 1)
      (1, 3)
      (2, 1, 1)
      (2, 2)
      (3, 1)
      请注意，顺序不同的序列被视作不同的组合。
      因此输出为 7。
进阶：
      如果给定的数组中含有负数会怎么样？
      问题会产生什么变化？
      我们需要在题目中添加什么限制来允许负数的出现？
```

## 7 找零钱的硬币数组合
518\. Coin Change 2 (Medium)

[力扣](https://leetcode-cn.com/problems/coin-change-2/description/) / [Leetcode](https://leetcode.com/problems/coin-change-2/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L518-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L518-m.py) 
```
题目:给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 
示例 1:
      输入: amount = 5, coins = [1, 2, 5]
      输出: 4
      解释: 有四种方式可以凑成总金额:
      5=5
      5=2+2+1
      5=2+1+1+1
      5=1+1+1+1+1
示例 2:
      输入: amount = 3, coins = [2]
      输出: 0
      解释: 只用面额2的硬币不能凑成总金额3。
```

# 特殊状态转移方程
## 1 格雷编码
89\. Gray Code

[力扣](https://leetcode-cn.com/problems/gray-code/) / [Leetcode](https://leetcode.com/problems/gray-code/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L89-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L89-m.py)   
```
题目: 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。
     给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。
     格雷编码序列必须以 0 开头。
示例 1:
      输入: 2
      输出: [0,1,3,2]
      解释:
      00 - 0
      01 - 1
      11 - 3
      10 - 2

      对于给定的 n，其格雷编码序列并不唯一。
      例如，[0,2,3,1] 也是一个有效的格雷编码序列。

      00 - 0
      10 - 2
      11 - 3
      01 - 1
```

## 2 比特位计数
338\. Counting Bits

[力扣](https://leetcode-cn.com/problems/counting-bits/) / [Leetcode](https://leetcode.com/problems/counting-bits/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L338-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L338-m.py) 
```
题目: 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
进阶:
      给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
      要求算法的空间复杂度为O(n)
```

## 3 解码方法
91\. Decode Ways (Medium)

[力扣](https://leetcode-cn.com/problems/decode-ways/description/) / [Leetcode](https://leetcode.com/problems/decode-ways/description/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L91-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L91-m.py) 
```
题目:一条包含字母 A-Z 的消息通过以下方式进行了编码：
   'A' -> 1
   'B' -> 2
   ...
   'Z' -> 26
   给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:
      输入: "12"
      输出: 2
      解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
      示例 2:

      输入: "226"
      输出: 3
      解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 
```

## 4 复制粘贴字符
650\. 2 Keys Keyboard (Medium)

[力扣](https://leetcode-cn.com/problems/2-keys-keyboard/description/) / [Leetcode](https://leetcode.com/problems/2-keys-keyboard/description/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L650-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L650-m.py) 
```
题目: 最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：
     Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
     Paste (粘贴) : 你可以粘贴你上一次复制的字符。
给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。
示例 1:
      输入: 3
      输出: 3
      解释:
      最初, 我们只有一个字符 'A'。
      第 1 步, 我们使用 Copy All 操作。
      第 2 步, 我们使用 Paste 操作来获得 'AA'。
      第 3 步, 我们使用 Paste 操作来获得 'AAA'。
```

## 5 整数拆分
343\. Integer Break (Medim)

[力扣](https://leetcode-cn.com/problems/integer-break/description/) / [Leetcode](https://leetcode.com/problems/integer-break/description/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L343.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L343.py) 
```
题目: 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
示例 1:
      输入: 2
      输出: 1
      解释: 2 = 1 + 1, 1 × 1 = 1。
      示例 2:

      输入: 10
      输出: 36
      解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
      说明: 你可以假设 n 不小于 2 且不大于 58。
```

## 6 整数拆分成最少平方数之和
279\. Perfect Squares(Medium)

[力扣](https://leetcode-cn.com/problems/perfect-squares/description/) / [Leetcode](https://leetcode.com/problems/perfect-squares/description/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L279-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L279-m.py) 
```
题目: 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
示例 1:
      输入: n = 12
      输出: 3 
      解释: 12 = 4 + 4 + 4.
```

## 7 不同的二叉搜索树
96\. Unique Binary Search Trees

[力扣](https://leetcode-cn.com/problems/unique-binary-search-trees/) / [Leetcode](https://leetcode.com/problems/unique-binary-search-trees/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L96-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L96-m.py) 
```
题目: 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
示例:
            输入: 3
            输出: 5
            解释:
            给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

               1         3     3      2      1
                \       /     /      / \      \
                 3     2     1      1   3      2
                /     /       \                 \
               2     1         2                 3
```


# 矩阵路径
## 1 不同路径
62\. Unique Paths (Medium)

[力扣](https://leetcode-cn.com/problems/unique-paths/description/) / [Leetcode](https://leetcode.com/problems/unique-paths/description/) / [Cpp](../algo_05_dynamic_plan/dp_7_matrix_path/L62-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_7_matrix_path/L62-m.py) 
```
题目: 一个机器人位于一个 m x n 网格的左上角 
     机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。
     问总共有多少条不同的路径？
```

## 2 最小路径和
64\. Minimum Path Sum (Medium)

[力扣](https://leetcode-cn.com/problems/minimum-path-sum/description/) / [Leetcode](https://leetcode.com/problems/minimum-path-sum/description/) / [Cpp](../algo_05_dynamic_plan/dp_7_matrix_path/L64-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_7_matrix_path/L64-m.py) 
```
题目:给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
示例:
      输入:
      [
        [1,3,1],
        [1,5,1],
        [4,2,1]
      ]
      输出: 7
      解释: 因为路径 1→3→1→1→1 的总和最小。
```


# 矩形问题  
## 1 最大正方形
221\. Maximal Square

[力扣](https://leetcode-cn.com/problems/maximal-square/) / [Leetcode](https://leetcode.com/problems/maximal-square/) / [Cpp](../algo_05_dynamic_plan/dp_8_max_matrix/L221-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_8_max_matrix/L221-m.py) 
```
题目:在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
示例:
      输入: 
      1 0 1 0 0
      1 0 1 1 1
      1 1 1 1 1
      1 0 0 1 0
      输出: 4
```

## 2 最大矩形
85\. Maximal Rectangle (hard)

[力扣](https://leetcode-cn.com/problems/maximal-rectangle/) / [Leetcode](https://leetcode.com/problems/maximal-rectangle/) / [Cpp](../algo_05_dynamic_plan/dp_8_max_matrix/L85-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_8_max_matrix/L85-h.py) 
```
题目:给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
示例:
      输入:
      [
        ["1","0","1","0","0"],
        ["1","0","1","1","1"],
        ["1","1","1","1","1"],
        ["1","0","0","1","0"]
      ]
      输出: 6
```

# 股票问题
## 1 买卖股票一次交易
121\. Best Time to Buy and Sell Stock

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) / [Cpp](../algo_05_dynamic_plan/dp_9_stock/L121.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/L121.py) 
```
题目:给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
    如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
    注意：你不能在买入股票前卖出股票。
示例 1:
      输入: [7,1,5,3,6,4]
      输出: 5
      解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
           注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

## 2 买卖股票不限次数
122\. Best Time to Buy and Sell Stock II

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) / [Cpp](../algo_05_dynamic_plan/dp_9_stock/L122.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/L122.py) 
```
题目: 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
     设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
     注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）
示例 1:
      输入: [7,1,5,3,6,4]
      输出: 7
      解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
           随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

## 3 最佳买卖股票时机含冷冻期不限次数
309\. Best Time to Buy and Sell Stock with Cooldown(Medium)

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/) /  [Cpp](../algo_05_dynamic_plan/dp_9_stock/) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/) 
```
题目:给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
    设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
    你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
    卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例:
      输入: [1,2,3,0,2]
      输出: 3 
      解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

## 4 买卖股票的最佳时机含手续费不限次数
714\. Best Time to Buy and Sell Stock with Transaction Fee (Medium)

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/) / [Cpp](../algo_05_dynamic_plan/dp_9_stock/) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/) 
```
题目:给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。
    你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
    返回获得利润的最大值。
    注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
示例 1:
      输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
      输出: 8
      解释: 能够达到的最大利润:  
      在此处买入 prices[0] = 1
      在此处卖出 prices[3] = 8
      在此处买入 prices[4] = 4
      在此处卖出 prices[5] = 9
      总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

## 5 只能进行两次的股票交易
123\. Best Time to Buy and Sell Stock III (Hard)

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/description/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/) / [Cpp](../algo_05_dynamic_plan/dp_9_stock/) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/) 
```
题目:给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
    设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
    注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
      输入: [3,3,5,0,0,3,1,4]
      输出: 6
      解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
           随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2:
      输入: [1,2,3,4,5]
      输出: 4
      解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
           注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
           因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

## 6 只能进行k次的股票交易
188\. Best Time to Buy and Sell Stock IV (Hard)

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/description/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/) / [Cpp](../algo_05_dynamic_plan/dp_9_stock/) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/) 
```
题目:给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
    设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
    注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
      输入: [2,4,1], k = 2
      输出: 2
      解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
示例 2:
      输入: [3,2,6,5,0,3], k = 2
      输出: 7
      解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
           随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```
