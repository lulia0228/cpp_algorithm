<!-- GFM-TOC -->
* [一 简单公式递推](#简单公式递推)
    * [1. 爬楼梯](#1-爬楼梯)
    * [2. 母牛生产](#2-母牛生产)
    * [3. 斐波那契数](#3-斐波那契数)
    * [4. 圆环回原点问题](#4-圆环回原点问题) 
    * [5. 变态跳](#5-变态跳)   
    
* [二 单序列一维线性](#单序列一维线性)
    * [1. 连续子数组：和最大](#1-最大连续子数组和)
    * [2. 连续子数组：乘积最大](#2-最大连续子数组乘积)
    * [3. 打家劫舍 ](#3-打家劫舍 )
    * [4. 打家劫舍II](#4-打家劫舍II)
    * [5. 整数拆分](#5-整数拆分)
    * [6. 最长的括号子串](#6-最长的括号子串)
    * [7. 最长连续递增序列](#7-最长连续递增序列)
    * [8. 数组中等差递增子区间的个数](#8-数组中等差递增子区间的个数)
    * [9. 最长摆动子序列](#9-最长摆动子序列)
    * [10. 规划兼职工作](#10-规划兼职工作)

* [三 单序列一维双向](#单序列一维双向)
    * [1. 数组中的最长山脉](#1-数组中的最长山脉) 
    * [2. 删除一次得到子数组最大和](#2-删除一次得到子数组最大和) 
    * [3. 牛牛的数列 ](#3-牛牛的数列 )  

* [四 单序列一维平方](#单序列一维平方)
    * [1. 最长上升子序列](#1-最长上升子序列)
    * [2. 俄罗斯套娃信封问题](#2-俄罗斯套娃信封问题)
    * [3. 一组整数对能够构成的最长链](#3-一组整数对能够构成的最长链)
    * [4. 最长等差数列](#4-最长等差数列)
    * [5. 最长递增子序列的个数](#5-最长递增子序列的个数)

* [五 单序列二维](#单序列二维)
    * [1. 分割数组的最大值](#1-分割数组的最大值) 
    * [2. 青蛙过河](#2-青蛙过河)  

* [六 双序列问题](#双序列问题)
    * [1. 编辑距离](#1-编辑距离)
    * [2. 最长公共连续子数组](#2-最长公共连续子数组)
    * [3. 最长公共子序列](#3-最长公共子序列)
    * [4. 删除两个字符串的字符使它们相等](#4-删除两个字符串的字符使它们相等)
    * [5. 最长公共子序列2](#5-最长公共子序列2)
    * [6. 通配符匹配](#6-通配符匹配)
    * [7. 正则表达式匹配](#7-正则表达式匹配)
    * [8. 交错字符串](#8-交错字符串)
    * [9. 不同的子序列](#9-不同的子序列)

* [七 字符串](#字符串)
    * [1. 解码方法](#1-解码方法) 
    * [2. 单词拆分](#2-单词拆分)  
    * [3. 单词拆分II](#3-单词拆分II) 
    * [4. 最长回文子串](#4-最长回文子串)  
    * [5. 最长回文子序列](#5-最长回文子序列)  
    * [6. 回文子串](#6-回文子串)  
    * [7. 让字符串成为回文串的最少插入次数](#7-让字符串成为回文串的最少插入次数)  
    * [8. 分割回文串](#8-分割回文串)  
    * [9. 分割回文串II](#9-分割回文串II)  

* [八 背包问题](#背包问题)
    * [1. 目标和](#1-目标和)
    * [2. 分割等和子集](#2-分割等和子集)
    * [3. 一和零](#3-一和零)
    * [4. 单词拆分](#4-单词拆分)
    * [5. 零钱兑换](#5-零钱兑换)
    * [6. 组合总和](#6-组合总和)
    * [7. 找零钱的硬币数组合](#7-找零钱的硬币数组合)
    * [8. 掷骰子的N种方法](#8-掷骰子的N种方法)
    * [9. n个骰子的点数](#9-n个骰子的点数)


* [九 特殊状态转移方程](#特殊状态转移方程)
    * [1. 格雷编码](#1-格雷编码) 
    * [2. 丑数II](#2-丑数II) 
    * [3. 戳气球](#3-戳气球) 
    * [4. 不同的二叉搜索树](#4-不同的二叉搜索树) 
    * [5. 比特位计数](#5-比特位计数)
    * [6. 复制粘贴字符](#6-复制粘贴字符)
    * [7. 整数拆分成最少平方数之和](#7-整数拆分成最少平方数之和)
    * [8. 数的划分](#8-数的划分)

* [十 矩阵输入](#矩阵输入)
    * [1. 不同路径](#1-不同路径)
    * [2. 不同路径II](#2-不同路径II)
    * [3. 最小路径和](#3-最小路径和)
    * [4. 最大正方形](#4-最大正方形)
    * [5. 三角形最小路径和](#5-三角形最小路径和)
    * [6. 下降路径最小和](#6-下降路径最小和)
    * [7. 马在棋盘上的概率](#7-马在棋盘上的概率)
    * [8. 最大的以1为边界的正方形](#8-最大的以1为边界的正方形)
    * [9. 最大矩形](#9-最大矩形)
   
* [十一 股票问题](#股票问题)
    * [1. 买卖股票一次交易](#1-买卖股票一次交易)
    * [2. 买卖股票不限次数](#2-买卖股票不限次数)
    * [3. 最佳买卖股票时机含冷冻期不限次数](#3-最佳买卖股票时机含冷冻期不限次数)
    * [4. 买卖股票的最佳时机含手续费不限次数](#4-买卖股票的最佳时机含手续费不限次数)
    * [5. 只能进行两次的股票交易](#5-只能进行两次的股票交易)
    * [6. 只能进行k次的股票交易](#6-只能进行k次的股票交易)

<!-- GFM-TOC -->
```
动态规划问题在于找出状态转移方程，此外，根据方程中所需要的上一个状态的变量情况，适当优化存储空间。
```

# 简单公式递推
## 1 爬楼梯    
70\. Climbing Stairs (Easy)

[力扣](https://leetcode-cn.com/problems/climbing-stairs/description/) / [Leetcode](https://leetcode.com/problems/climbing-stairs/description/) / [Cpp](../algo_05_dynamic_plan/dp_1_simple_recursion_formula/L70.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_1_simple_recursion_formula/L70.py)    

```
题目:假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
```

## 2 母牛生产
```
题目：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只成熟母牛，从第二年开始，
母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后母牛的数量。
DP方程：i >= 4 dp[i] = dp[i-1] + dp[i-3] 后一项代表的是当前年成熟的母牛的个数
```

## 3 斐波那契数    
509\. 斐波那契数

[力扣](https://leetcode-cn.com/problems/fibonacci-number/) / [Leetcode](https://leetcode.com/problems/fibonacci-number/) / [Cpp](../algo_05_dynamic_plan/dp_1_simple_recursion_formula/L70.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_1_simple_recursion_formula/L70.py)    

```
题目:斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，
    后面的每一项数字都是前面两项数字的和。也就是：
            F(0) = 0，F(1) = 1
            F(n) = F(n - 1) + F(n - 2)，其中 n > 1
    给你 n ，请计算 F(n) 。 【n太大怎么办？用迭代器yield】
```

## 4 圆环回原点问题    
000\. 圆环回原点问题

[codetop](https://mp.weixin.qq.com/s?__biz=MzkxNDI1MTA1MA==&mid=2247484403&idx=1&sn=8520fcdb843f6caeb0683e158cf7548c&source=41#wechat_redirect) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_1_simple_recursion_formula/b圆环回原点问题.py)    

```
题目:圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。
      输入: 2
      输出: 2
      解释：有2种方案。分别是0->1->0和0->9->0
思想：走n步到0的方案数=走n-1步到1的方案数+走n-1步到9的方案数。
DP方程：dp[i][j] = dp[i-1][(j-1+length)%length] + dp[i-1][(j+1)%length]

class Solution:
    def backToOrigin(self,n):
        #点的个数为10
        length = 10
        dp = [[0 for i in range(length)] for j in range(n+1)]
        dp[0][0] = 1
        for i in range(1,n+1):
            for j in range(length):
                #dp[i][j]表示从0出发，走i步到j的方案数
                dp[i][j] = dp[i-1][(j-1+length)%length] + dp[i-1][(j+1)%length]
        return dp[n][0]
```

## 5 变态跳    
```
题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。   
分析：因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级  
跳1级，剩下n-1级，则剩下跳法是f(n-1)
跳2级，剩下n-2级，则剩下跳法是f(n-2)

所以f(n) = f(n-1) + f(n-2) + ... + f(1)
因为f(n-1) = f(n-2) + f(n-3 )+ ... + f(1)
所以f(n) = 2 * f(n-1)。
根据f(1) = 1，f(n) = 2 * f(n-1)，可以得出f(n) = 2^(n-1)。
```


# 单序列一维线性
## 1 最大连续子数组和
53\. Maximum Subarray

[力扣](https://leetcode-cn.com/problems/maximum-subarray/) / [Leetcode](https://leetcode.com/problems/maximum-subarray/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L53.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L53.py)   
```
题目:给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
```

## 2 最大连续子数组乘积
152\. Maximum Product Subarray

[力扣](https://leetcode-cn.com/problems/maximum-product-subarray/) / [Leetcode](https://leetcode.com/maximum-product-subarray/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L152-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L152-m.py)   
```
题目:给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
```
## 3 打家劫舍
198\. House Robber (Easy)
NC144\. 不相邻最大子序列和   

[力扣](https://leetcode-cn.com/problems/house-robber/description/) / [Leetcode](https://leetcode.com/problems/house-robber/description/) / [Cpp](../algo_05_dynamic_plan/dp_5_rob/L198.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_5_rob/L198.py) 
```
题目: 一排房屋，给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置(不能偷2家挨着)
     的情况下 ，一夜之内能够偷窃到的最高金额。
```

## 4 打家劫舍II
213\. House Robber II (Medium)

[力扣](https://leetcode-cn.com/problems/house-robber-ii/description/) / [Leetcode](https://leetcode.com/problems/house-robber-ii/description/) / [Cpp](../algo_05_dynamic_plan/dp_5_rob/L213-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_5_rob/L213-m.py) 
```
题目：环形排列房屋，给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
```

## 5 整数拆分
343\. Integer Break (Medim)

[力扣](https://leetcode-cn.com/problems/integer-break/description/) / [Leetcode](https://leetcode.com/problems/integer-break/description/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L343.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L343.py) 
```
题目: 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
示例 1:
      输入: 2
      输出: 1
      解释: 2 = 1 + 1, 1 × 1 = 1。
      示例 2:

      输入: 10
      输出: 36
      解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
      说明: 你可以假设 n 不小于 2 且不大于 58。
```

## 6 最长的括号子串
32\. 最长有效括号
NC49\. 最长的括号子串

[力扣](https://leetcode-cn.com/problems/longest-valid-parentheses/) / [Leetcode](https://leetcode.com/problems/longest-valid-parentheses/) / [Cpp](../algo_05_dynamic_plan/dp_5_rob/L32-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_5_rob/L32-h.py) 

```
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
示例 1：
      输入：s = "(()"
      输出：2
      解释：最长有效括号子串是 "()"
示例 2：
      输入：s = ")()())"
      输出：4
      解释：最长有效括号子串是 "()()"
```

## 7 最长连续递增序列
674\. 最长连续递增序列

[力扣](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/) / [Leetcode](https://leetcode.com/problems/longest-continuous-increasing-subsequence/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L674.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L674.py)   
```
题目：给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，
都有 nums[i] < nums[i + 1] ，那么子序列 
[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。
示例 1：
      输入：nums = [1,3,5,4,7]
      输出：3
      解释：最长连续递增序列是 [1,3,5], 长度为3。
      尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。
```

## 8 数组中等差递增子区间的个数
413\. Arithmetic Slices (Medium)

[力扣](https://leetcode-cn.com/problems/arithmetic-slices/description/) / [Leetcode](https://leetcode.com/problems/arithmetic-slices/description/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L413-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L413-m.py)   
```
题目: 返回数组中是等差数列的连续子数组(长度至少为3)的个数。
```

## 9 最长摆动子序列
376\. Wiggle Subsequence (Medium)

[力扣](https://leetcode-cn.com/problems/wiggle-subsequence/description/) / [Leetcode](https://leetcode.com/problems/wiggle-subsequence/description/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L376-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L376-m.py)   
```
题目：从给定数组中找到长度最长的摆动子序列。通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。
进阶:
     你能否用 O(n) 时间复杂度完成此题?
```

## 10 规划兼职工作
1235\. 规划兼职工作

[力扣](https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/) / [Leetcode](https://leetcode.com/problems/maximum-profit-in-job-scheduling/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L1235-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L1235-h.py)   
```
题目：这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。
   给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，
   请你计算并返回可以获得的最大报酬。
   注意，时间上出现重叠的 2 份工作不能同时进行。
   如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。
```

# 单序列一维双向
## 1 数组中的最长山脉
845\. 数组中的最长山脉

[力扣](https://leetcode-cn.com/problems/longest-mountain-in-array/) / [Leetcode](https://leetcode.com/problems/longest-mountain-in-array/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L845-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L845-m.py)   
```
题目:我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：
      B.length >= 3
      存在 0 < i < B.length - 1 使得
      B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]
      （注意：B 可以是 A 的任意子数组，包括整个数组 A。）
给出一个整数数组 A，返回最长 “山脉” 的长度。如果不含有 “山脉” 则返回 0。
示例 1：
      输入：[2,1,4,7,3,2,5]
      输出：5
      解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。
示例 2：
      输入：[2,2,2]
      输出：0
      解释：不含 “山脉”。
```

## 2 删除一次得到子数组最大和
1186\. 删除一次得到子数组最大和

[力扣](https://leetcode-cn.com/problems/maximum-subarray-sum-with-one-deletion/) / [Leetcode](https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L1186-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L1186-m.py)   
```
题目:给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。
换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），
（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。
注意，删除一个元素后，子数组 不能为空。
示例 1：
      输入：arr = [1,-2,0,3]
      输出：4
      解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。
示例 2： 
      输入：arr = [1,-2,-2,3]
      输出：3
      解释：我们直接选出 [3]，这就是最大和。
```

## 3 牛牛的数列
NC155\. 牛牛的数列

[牛客](https://www.nowcoder.com/practice/f2419f68541d499f920eac51c63d3f72?tpId=117&&tqId=37865&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/NC155.py)   
```
给定一个数组，最多只改变一个数,就可以使得数组的一个连续的子序列是严格上升的子序列,牛牛想知道这个连续子序列最长的长度是多少。
```

# 单序列一维平方
## 1 最长上升子序列
300\. Longest Increasing Subsequence (Medium)

[力扣](https://leetcode-cn.com/problems/longest-increasing-subsequence/description/) / [Leetcode](https://leetcode.com/problems/longest-increasing-subsequence/description/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L300.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L300.py)   
```
题目:给定一个无序的整数数组，找到其中最长上升子序列的长度。
示例:
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:
   可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
   你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
```

## 2 俄罗斯套娃信封问题
354\. 俄罗斯套娃信封问题
NC153\. 信封嵌套问题   


[力扣](https://leetcode-cn.com/problems/russian-doll-envelopes/) / [Leetcode](https://leetcode.com/problems/russian-doll-envelopes/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L354-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L354-h.py)   
```
题目:给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。
当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。
请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。
注意：不允许旋转信封。
示例 1：
      输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
      输出：3
      解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
示例 2：
      输入：envelopes = [[1,1],[1,1],[1,1]]
      输出：1
```

## 3 一组整数对能够构成的最长链
646\. Maximum Length of Pair Chain (Medium)

[力扣](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/description/) / [Leetcode](https://leetcode.com/problems/maximum-length-of-pair-chain/description/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L646-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L646-m.py)   
```
题目: 给出 n 个数对, 在每一个数对中，第一个数字总是比第二个数字小。
现在，我们定义一种跟随关系，当且仅当 b < c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。
给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。
示例 :
输入: [[1,2], [2,3], [3,4]]
输出: 2
解释: 最长的数对链是 [1,2] -> [3,4]
注意：给出数对的个数在 [1, 1000] 范围内。
```

## 4 最长等差数列
1027\. 最长等差数列

[力扣](https://leetcode-cn.com/problems/longest-arithmetic-subsequence/) / [Leetcode](https://leetcode-cn.com/problems/longest-arithmetic-subsequence/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L1027-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L1027-m.py)   
```
题目: 给定一个整数数组 A，返回 A 中最长等差子序列的长度。
回想一下，A 的子序列是列表 A[i_1], A[i_2], ..., A[i_k] 其中 0 <= i_1 < i_2 < ... < i_k <= A.length - 1。
并且如果 B[i+1] - B[i]( 0 <= i < B.length - 1) 的值都相同，那么序列 B 是等差的。
示例 1：
      输入：[3,6,9,12]
      输出：4
      解释： 整个数组是公差为 3 的等差数列。
示例 2：
      输入：[9,4,7,2,10]
      输出：3
      解释：
      最长的等差子序列是 [4,7,10]。

```

## 5 最长递增子序列的个数
673\. 最长递增子序列的个数

[力扣](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/) / [Leetcode](https://leetcode.com/problems/number-of-longest-increasing-subsequence/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L673-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L673-m.py)   
```
题目: 给定一个未排序的整数数组，找到最长递增子序列的个数。
示例 1:
      输入: [1,3,5,4,7]
      输出: 2
      解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2:
      输入: [2,2,2,2,2]
      输出: 5
      解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
```

# 单序列二维
## 1 分割数组的最大值
410\. 分割数组的最大值

[力扣](https://leetcode-cn.com/problems/split-array-largest-sum/) / [Leetcode](https://leetcode.com/problems/split-array-largest-sum/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L410-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L410-h.py)   
```
题目:给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m 个非空的连续子数组。
设计一个算法使得这 m 个子数组各自和的最大值最小。
示例 1：
      输入：nums = [7,2,5,10,8], m = 2
      输出：18
      解释：
      一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
      因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```

## 2 青蛙过河
403. 青蛙过河

[力扣](https://leetcode-cn.com/problems/frog-jump/) / [Leetcode](https://leetcode.com/problems/frog-jump/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L403-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L403-h.py)   
```
题目:一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 
青蛙可以跳上石子，但是不可以跳入水中。
给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。
开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。
如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 
另请注意，青蛙只能向前方（终点的方向）跳跃。
示例 1：
      输入：stones = [0,1,3,5,6,8,12,17]
      输出：true
      解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子,
      接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 
      最后，跳 5 个单位到第 8 个石子（即最后一块石子）。
```



# 双序列问题
## 1 编辑距离
72\. Edit Distance (Hard)

[力扣](https://leetcode-cn.com/problems/edit-distance/description/) / [Leetcode](https://leetcode.com/problems/edit-distance/description/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L72-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L72-h.py)   
```
题目:给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
      插入一个字符
      删除一个字符
      替换一个字符
示例 1：
      输入：word1 = "horse", word2 = "ros"
      输出：3
      解释：
      horse -> rorse (将 'h' 替换为 'r')
      rorse -> rose (删除 'r')
      rose -> ros (删除 'e')
```

## 2 最长公共连续子数组
718\. Maximum Length of Repeated Subarray

[力扣](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/) / [Leetcode](https://leetcode.com/problems/maximum-length-of-repeated-subarray/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L718-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L718-m.py)   
```
题目: 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。
示例：
      输入：
      A: [1,2,3,2,1]
      B: [3,2,1,4,7]
      输出：3
      解释：
      长度最长的公共子数组是 [3, 2, 1] 。
```

## 3 最长公共子序列
1143\. Longest Common Subsequence

[力扣](https://leetcode-cn.com/problems/longest-common-subsequence/) / [Leetcode](https://leetcode.com/problems/longest-common-subsequence/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L1143-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L1143-m.py)   
```
题目：给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
     一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符
    （也可以不删除任何字符）后组成的新字符串。例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 
     的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
     若这两个字符串没有公共子序列，则返回 0。
```

## 4 删除两个字符串的字符使它们相等
583\. Delete Operation for Two Strings (Medium)

[力扣](https://leetcode-cn.com/problems/delete-operation-for-two-strings/description/) / [Leetcode](https://leetcode.com/problems/delete-operation-for-two-strings/description/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L583-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L583-m.py)   
```
题目:给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符
示例：
      输入: "sea", "eat"
      输出: 2
      解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

## 5 最长公共子序列2
NC92\. 最长公共子序列2   

[牛客](https://www.nowcoder.com/practice/6d29638c85bb4ffd80c020fe244baf11?tpId=117&&tqId=37798&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/NC152.py)   
```
题目：给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回"-1"。
目前给出的数据，仅仅会存在一个最长的公共子序列
输入："1A2C3D4B56","B1D23A456A"
输出:"123456"
```

## 6 通配符匹配
44\. 通配符匹配

[力扣](https://leetcode-cn.com/problems/delete-operation-for-two-strings/description/) / [Leetcode](https://leetcode.com/problems/delete-operation-for-two-strings/description/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L583-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L583-m.py)   
```
题目:给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符
示例：
      输入: "sea", "eat"
      输出: 2
      解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

## 7 正则表达式匹配
10\. 正则表达式匹配

[力扣](https://leetcode-cn.com/problems/regular-expression-matching/) / [Leetcode](https://leetcode.com/problems/regular-expression-matching/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L10-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L10-h.py)   
```
题目:给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
示例 1：
      输入：s = "aa" p = "a"
      输出：false
      解释："a" 无法匹配 "aa" 整个字符串。
示例 2:
      输入：s = "aa" p = "a*"
      输出：true
      解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

## 8 交错字符串
97\. 交错字符串

[力扣](https://leetcode-cn.com/problems/delete-operation-for-two-strings/description/) / [Leetcode](https://leetcode.com/problems/delete-operation-for-two-strings/description/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L583-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L583-m.py)   
```
题目:给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符
示例：
      输入: "sea", "eat"
      输出: 2
      解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

## 9 不同的子序列
115\. 不同的子序列  

[力扣](https://leetcode-cn.com/problems/delete-operation-for-two-strings/description/) / [Leetcode](https://leetcode.com/problems/delete-operation-for-two-strings/description/) / [Cpp](../algo_05_dynamic_plan/dp_3_two_sequence/L583-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_3_two_sequence/L583-m.py)   
```
题目:给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符
示例：
      输入: "sea", "eat"
      输出: 2
      解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

# 字符串
## 1 解码方法
91\. Decode Ways (Medium)

[力扣](https://leetcode-cn.com/problems/decode-ways/description/) / [Leetcode](https://leetcode.com/problems/decode-ways/description/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L91-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L91-m.py) 
```
题目:一条包含字母 A-Z 的消息通过以下方式进行了编码：
   'A' -> 1
   'B' -> 2
   ...
   'Z' -> 26
   给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:
      输入: "12"
      输出: 2
      解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
      示例 2:

      输入: "226"
      输出: 3
      解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 
```

## 1 最长回文子串
5\. Longest Palindromic Substring

[力扣](https://leetcode-cn.com/problems/longest-palindromic-substring/) / [Leetcode](https://leetcode.com/problems/longest-palindromic-substring/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L5-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L5-m.py) 

## 2 单词拆分
139\. Word Break (Medium)

[力扣](https://leetcode-cn.com/problems/word-break/description/) / [Leetcode](https://leetcode.com/problems/word-break/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L139-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L139-m.py) 
```
题目:给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
说明：
      拆分时可以重复使用字典中的单词。
      你可以假设字典中没有重复的单词。

示例 1：
      输入: s = "leetcode", wordDict = ["leet", "code"]
      输出: true
      解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：
      输入: s = "applepenapple", wordDict = ["apple", "pen"]
      输出: true
      解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
           注意你可以重复使用字典中的单词。
示例 3：
      输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
      输出: false
条件：1维约束；每个单词可用任意次。     
目标：判断是否可以形成约束s。  
```

## 3 单词拆分II
140. Word Break II  Hard
【回溯或者dp】   

[力扣](https://leetcode-cn.com/problems/word-break-ii/) / [Leetcode](https://leetcode.com/problems/word-break-ii/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L140-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L140-h.py) 
```
题目:给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，
   使得句子中所有的单词都在词典中。返回所有这些可能的句子。  
说明：
   分隔时可以重复使用字典中的单词。
   你可以假设字典中没有重复的单词。
示例 1：
         输入:s = "catsanddog"
             wordDict = ["cat", "cats", "and", "sand", "dog"]
         输出:
         [
           "cats and dog",
           "cat sand dog"
         ]
示例 2：
         输入:s = "pineapplepenapple"
              wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
         输出:
         [
           "pine apple pen apple",
           "pineapple pen apple",
           "pine applepen apple"
         ]
         解释: 注意你可以重复使用字典中的单词。
```

 ## 4 最长回文子串
5\. Longest Palindromic Substring
  
[力扣](https://leetcode-cn.com/problems/longest-palindromic-substring/) / [Leetcode](https://leetcode.com/problems/longest-palindromic-substring/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L5-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L5-m.py) 
 
 ```   
给你一个字符串 s，找到 s 中最长的回文子串。
示例 1：
      输入：s = "babad"
      输出："bab"
      解释："aba" 同样是符合题意的答案。
示例 2：
      输入：s = "cbbd"
      输出："bb"
```


## 5 最长回文子序列  
516\. 最长回文子序列
NC154\. 最长回文子序列  

[力扣](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) / [Leetcode](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) / [Cpp](../algo_05_dynamic_plan/dp_2_subsequence/L516-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_2_subsequence/L516-m.py) 
```
给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。
示例 1:
输入:"bbbab"
输出:4
```

## 6 回文子串
647\. Palindromic Substrings    

[力扣](https://leetcode-cn.com/problems/palindromic-substrings/) / [Leetcode](https://leetcode.com/problems/palindromic-substrings/) / [Cpp](../ds_6_string/palindrome_string/L647-m.cpp) / [Python3](../python-algorithm/ds_6_string/palindrome_string/L647-m.py)
```
题目：给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
     具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例：
      输入："aaa"
      输出：6
      解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

## 7 让字符串成为回文串的最少插入次数
1312\. Minimum Insertion Steps to Make a String Palindrome

[力扣](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/) / [Leetcode](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/) / [Cpp](../ds_6_string/palindrome_string/L1312-h.cpp) / [Python3](../python-algorithm/ds_6_string/palindrome_string/L1312-h.py)
```
题目：给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。
   请你返回让 s 成为回文串的 最少操作次数 。
   「回文串」是正读和反读都相同的字符串。
示例 1：
      输入：s = "zzazz"
      输出：0
解释：字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。
示例 2：
      输入：s = "mbadm"
      输出：2
      解释：字符串可变为 "mbdadbm" 或者 "mdbabdm" 。
示例 3：
      输入：s = "leetcode"
      输出：5
      解释：插入 5 个字符后字符串变为 "leetcodocteel" 。
```

## 8 分割回文串
131\. Palindrome Partitioning 

[力扣](https://leetcode-cn.com/problems/palindrome-partitioning/) / [Leetcode](https://leetcode.com/problems/palindrome-partitioning/) / [Cpp](../ds_6_string/palindrome_string/L131-m.cpp) / [Python3](../python-algorithm/ds_6_string/palindrome_string/L131-m.py)
```
题目：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
回文串 是正着读和反着读都一样的字符串。
示例 1：
      输入：s = "aab"
      输出：[["a","a","b"],["aa","b"]]
示例 2：
      输入：s = "a"
      输出：[["a"]]
```

## 9 分割回文串II
132\. Palindrome Partitioning II 

[力扣](https://leetcode-cn.com/problems/palindrome-partitioning-ii/) / [Leetcode](https://leetcode-cn.com/problems/palindrome-partitioning-ii/) / [Cpp](../ds_6_string/palindrome_string/L132-h.cpp) / [Python3](../python-algorithm/ds_6_string/palindrome_string/L132-h.py)
```
题目：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。
返回符合要求的 最少分割次数 。
示例 1：
   输入：s = "aab"
   输出：1
   解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
```

# 背包问题  
背包问题分类：     
（1）一维约束：原始背包问题就是1维约束问题，只有重量约束。      
（2）多维约束：背包问题里面除了有重量约束，再添加一个体积约束，就是二维约束问题。      
（3）完全背包：每个物品可以使用无限次     
（4）不完全背包：每个物品可使用的次数有限   

背包问题细分：    
来自leetcode347 题解作者：Jackie1995     
1、组合问题：377组合总和Ⅳ    494目标和    518找零组合数   
2、存在问题：416分割等和子集   139单词拆分   
3、最值问题：474一和零    322最少硬币找零数   

以上3类的状态转移方程：     
dp[i] += dp[i-num]   
dp[i] = dp[i] or dp[i-num]   
dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)  

背包问题分析步骤：   
1.分析是否为背包问题。   
2.是以上三种背包问题中的哪一种。   
3.是0-1背包问题还是完全背包问题。也就是题目给的nums数组中的元素是否可以重复使用。   
4.如果是组合问题，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法。   

背包问题的判定：   
给定一个约束s，它可以是数字也可以是字符串（可以是1维度，也可是多维度，例如474一和零的各自使用次数上限），    
再给定一个数组nums，nums中装的可能是数字，也可能是字符串，问：能否使用nums中的元素做各种排列组合完成约束（存在问题）？     
或者是使用nums中的元素在完成约束的前提下使其它产物(组合问题、最值问题)达到目的？    

背包问题技巧：    
1.如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，约束在内循环，且内循环倒序。 （494）     
```
for num in nums:
    for i in range(s, num-1, -1):
````
2.如果是完全背包，即数组中的元素可重复使用，nums放在外循环，约束在内循环，且内循环正序。（518）    
```
for num in nums:
    for i in range(nums, s+1):
```
3.如果组合问题中不同顺序的相同元素序列算做不同，需将约束放在外循环，将nums放在内循环。（377）          
```
for i in range(1, s+1):
    for num in nums:
```

## 原始问题：      
问题描述：现有n个物品，每个的重量用数组w表示，每个物品的价值用数组v表示，     
现有一个背包最大承重为C，求用这n个物品装入背包能获得的最大总价值？    

条件：1维约束；每个元素只可用1次。      
目标：总价值最大。
[牛客01背包](https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf?tpId=117&&tqId=37856&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)   
```
class Solution:
    def knapsack(self, w , v , C ):
        n = len(w)
        # dp[i][j]表示用[0,...,i-1]物品填充容量为j的最大价值
        dp = [[0]*(C+1) for i in range(n+1)]
        for i in range(1, n+1):
            for j in range(C+1):
                # 装或者不装第i个
                if j >= w[i]:
                    dp[i][j] = max(dp[i-1][j], v[i-1]+dp[i-1][j - w[i-1]])
                else:
                    dp[i][j] = dp[i-1][j]  # 不装第i个
        return dp[n][C]
 
 优化空间：即dp[j]同时表示原来的dp[i-1][j]和dp[i][j]   
 class Solution:
    def knapsack(self, w , v , C ):
        n = len(w)
        dp = [0]*(C+1)
        for i in range(n): # 每个元素只能使用1次
            # 只有倒着设计才能避免因为省略第1维度带来的原来俩维度的dp[i-1][j-w]正序计算会被提前覆盖的问题   
            for j in range(C, w[i-1]-1, -1):
                dp[j] = max(dp[j], v[i]+dp[j - w[i]])
        return dp[C]
```

## 1 目标和
## 从非负整数数组中挑选出部分元素，使它们的和等于target，问有多少种挑选方法？      
494\. Target Sum (Medium)

[力扣](https://leetcode-cn.com/problems/target-sum/description/) / [Leetcode](https://leetcode.com/problems/target-sum/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L494-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L494-m.py) 
```
题目: 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，
你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。
示例：
      输入：nums: [1, 1, 1, 1, 1], S: 3
      输出：5
      解释：
      -1+1+1+1+1 = 3
      +1-1+1+1+1 = 3
      +1+1-1+1+1 = 3
      +1+1+1-1+1 = 3
      +1+1+1+1-1 = 3
      一共有5种方法让最终目标和为3。
      
条件：1维约束；每个元素只可用1次。      
目标：可选择的方式总数。  
```

## 2 分割等和子集
## 判断是否可以从正整数数组中挑出部分元素，使他们的和为数组总和的一半。      
416\. Partition Equal Subset Sum (Medium)  

[力扣](https://leetcode-cn.com/problems/partition-equal-subset-sum/description/) / [Leetcode](https://leetcode.com/problems/partition-equal-subset-sum/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L416-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L416-m.py) 
```
题目: 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:
      每个数组中的元素不会超过 100
      数组的大小不会超过 200
示例 1:
      输入: [1, 5, 11, 5]
      输出: true
      解释: 数组可以分割成 [1, 5, 5] 和 [11].

条件：1维约束；每个元素只可用1次。      
目标：是否存在，bool。  
```

## 3 一和零 
474\. Ones and Zeroes (Medium)  
   
[力扣](https://leetcode-cn.com/problems/ones-and-zeroes/description/) / [Leetcode](https://leetcode.com/problems/ones-and-zeroes/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L474-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L474-m.py) 
```
题目: 在计算机界中，我们总是追求用有限的资源获取最大的收益。现在，假设你分别支配着 m 个 0 和 n 个 1。
     另外，还有一个仅包含 0 和 1 字符串的数组。你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出
     存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。
示例 1:
      输入: strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
      输出: 4
      解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。
      示例 2:

      输入: strs = ["10", "0", "1"], m = 1, n = 1
      输出: 2
      解释: 你可以拼出 "10"，但之后就没有剩余数字了。更好的选择是拼出 "0" 和 "1" 。
      
条件：2维约束；每个元素只可用1次。        
目标：能生成存在于给定集合的字符串的个数最多。  
```

## 4 单词拆分
139\. Word Break (Medium)

[力扣](https://leetcode-cn.com/problems/word-break/description/) / [Leetcode](https://leetcode.com/problems/word-break/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L139-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L139-m.py) 
```
题目:给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
说明：
      拆分时可以重复使用字典中的单词。
      你可以假设字典中没有重复的单词。

示例 1：
      输入: s = "leetcode", wordDict = ["leet", "code"]
      输出: true
      解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：
      输入: s = "applepenapple", wordDict = ["apple", "pen"]
      输出: true
      解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
           注意你可以重复使用字典中的单词。
示例 3：
      输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
      输出: false
条件：1维约束；每个单词可用任意次。     
目标：判断是否可以形成约束s。  
```

## 5 零钱兑换
322\. Coin Change (Medium)

[力扣](https://leetcode-cn.com/problems/coin-change/description/) / [Leetcode](https://leetcode.com/problems/coin-change/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L322-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L322-m.py) 
```
题目:给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
    如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。
示例 1：
      输入：coins = [1, 2, 5], amount = 11
      输出：3 
      解释：11 = 5 + 5 + 1
      示例 2：

      输入：coins = [2], amount = 3
      输出：-1

条件：1维约束；每个元素可用无限次。      
目标：找零需要的最少硬币数。      
```

## 6 组合总和
377\. Combination Sum IV (Medium)

[力扣](https://leetcode-cn.com/problems/combination-sum-iv/description/) / [Leetcode](https://leetcode.com/problems/combination-sum-iv/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L377-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L377-m.py) 
```
题目: 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。
示例:
      nums = [1, 2, 3]
      target = 4
      所有可能的组合为：
      (1, 1, 1, 1)
      (1, 1, 2)
      (1, 2, 1)
      (1, 3)
      (2, 1, 1)
      (2, 2)
      (3, 1)
      请注意，顺序不同的序列被视作不同的组合。
      因此输出为 7。
进阶：
      如果给定的数组中含有负数会怎么样？
      问题会产生什么变化？
      我们需要在题目中添加什么限制来允许负数的出现？   

条件：1维约束；每个元素可用无限次。        
目标：组合总数。      
```

## 7 找零钱的硬币数组合
518\. Coin Change 2 (Medium)

[力扣](https://leetcode-cn.com/problems/coin-change-2/description/) / [Leetcode](https://leetcode.com/problems/coin-change-2/description/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L518-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L518-m.py) 
```
题目:给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。   
注意:和377组合总和的区别在于，硬币组合数是不考虑顺序的，即顺序不同的相同元素序列算一种组合。    
示例 1:
      输入: amount = 5, coins = [1, 2, 5]
      输出: 4
      解释: 有四种方式可以凑成总金额:
      5=5
      5=2+2+1
      5=2+1+1+1
      5=1+1+1+1+1
示例 2:
      输入: amount = 3, coins = [2]
      输出: 0
      解释: 只用面额2的硬币不能凑成总金额3。

条件：1维约束；每个元素可用无限次。      
目标：找零的方式总数。      
```

## 8 掷骰子的N种方法
1155\. 掷骰子的N种方法

[力扣](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/) / [Leetcode](https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/L1155-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/L1155-m.py) 
```
这里有 d 个一样的骰子，每个骰子上都有 f 个面，分别标号为 1, 2, ..., f。
我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。
如果需要掷出的总点数为 target，请你计算出有多少种不同的组合情况
（所有的组合情况总共有 f^d 种），模 10^9 + 7 后返回。
示例 1：
      输入：d = 1, f = 6, target = 3
      输出：1
示例 2：
      输入：d = 2, f = 6, target = 7
      输出：6
示例 3：
      输入：d = 2, f = 5, target = 10
      输出：1
```

## 9 n个骰子的点数
剑指 Offer 60\. n个骰子的点数

[力扣](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/) / [Leetcode](https://leetcode.com/problems/nge-tou-zi-de-dian-shu-lcof/) / [Cpp](../algo_05_dynamic_plan/dp_6_knapsack_problem/J60-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_6_knapsack_problem/J60-m.py) 
```
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
示例 1:
      输入: 1
      输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
示例 2:
      输入: 2
      输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,
            0.13889,0.11111,0.08333,0.05556,0.02778]
限制：1 <= n <= 11
```


# 特殊状态转移方程
## 1 格雷编码
89\. Gray Code

[力扣](https://leetcode-cn.com/problems/gray-code/) / [Leetcode](https://leetcode.com/problems/gray-code/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L89-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L89-m.py)   
```
题目: 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。
     给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。
     格雷编码序列必须以 0 开头。
示例 1:
      输入: 2
      输出: [0,1,3,2]
      解释:
      00 - 0
      01 - 1
      11 - 3
      10 - 2

      对于给定的 n，其格雷编码序列并不唯一。
      例如，[0,2,3,1] 也是一个有效的格雷编码序列。

      00 - 0
      10 - 2
      11 - 3
      01 - 1
```

## 2 丑数II
264\. 丑数II

[力扣](https://leetcode-cn.com/problems/ugly-number-ii/) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L264-m.py) 
```
给你一个整数 n ，请你找出并返回第 n 个 丑数 。
丑数 就是只包含质因数 2、3 和/或 5 的正整数。
示例 1：
      输入：n = 10
      输出：12
      解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```

## 3 戳气球
312\. 戳气球

[力扣](https://leetcode-cn.com/problems/burst-balloons/) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L312-h.py) 
```
有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。
现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。
这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。
如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。
求所能获得硬币的最大数量。
示例 1：
      输入：nums = [3,1,5,8]
      输出：167
      解释：
      nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
      coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
```



    * [8. 一次编辑](#8-一次编辑)
    * [9. 硬币](#9-硬币)
    * [10. 马戏团人塔](#10-马戏团人塔)
    * [11. 丑数](#11-丑数)   
    * [12. 恢复空格](#12-恢复空格)  
    * [13. 最长单词](#12-最长单词)  
    * [14. 最大黑方阵](#14-最大黑方阵)  
    * [15. 数的划分](#15-数的划分)
    
## 4 不同的二叉搜索树
96\. Unique Binary Search Trees

[力扣](https://leetcode-cn.com/problems/unique-binary-search-trees/) / [Leetcode](https://leetcode.com/problems/unique-binary-search-trees/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L96-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L96-m.py) 
```
题目: 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
示例:
            输入: 3
            输出: 5
            解释:
            给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

               1         3     3      2      1
                \       /     /      / \      \
                 3     2     1      1   3      2
                /     /       \                 \
               2     1         2                 3
```

## 5 比特位计数
338\. Counting Bits

[力扣](https://leetcode-cn.com/problems/counting-bits/) / [Leetcode](https://leetcode.com/problems/counting-bits/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L338-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L338-m.py) 
```
题目: 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
进阶:
      给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
      要求算法的空间复杂度为O(n)
```


## 6 复制粘贴字符
650\. 2 Keys Keyboard (Medium)

[力扣](https://leetcode-cn.com/problems/2-keys-keyboard/description/) / [Leetcode](https://leetcode.com/problems/2-keys-keyboard/description/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L650-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L650-m.py) 
```
题目: 最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：
     Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
     Paste (粘贴) : 你可以粘贴你上一次复制的字符。
给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。
示例 1:
      输入: 3
      输出: 3
      解释:
      最初, 我们只有一个字符 'A'。
      第 1 步, 我们使用 Copy All 操作。
      第 2 步, 我们使用 Paste 操作来获得 'AA'。
      第 3 步, 我们使用 Paste 操作来获得 'AAA'。
```


## 7 整数拆分成最少平方数之和
279\. Perfect Squares(Medium)

[力扣](https://leetcode-cn.com/problems/perfect-squares/description/) / [Leetcode](https://leetcode.com/problems/perfect-squares/description/) / [Cpp](../algo_05_dynamic_plan/dp_4_special_state_transition/L279-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/L279-m.py) 
```
题目: 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
示例 1:
      输入: n = 12
      输出: 3 
      解释: 12 = 4 + 4 + 4.
```


## 8 数的划分 
NC152\. 数的划分   

[牛客](https://www.nowcoder.com/practice/24c2045f2cce40a5bf410a369a001da8?tpId=117&&tqId=37862&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_4_special_state_transition/NC152.py) 
```
将整数n分成k份，且每份不能为空，任意两个方案不能相同(不考虑顺序)。
例如：n=7，k=3，下面三种分法被认为是相同的。
1，1，5;
1，5，1;
5，1，1;
问有多少种不同的分法。
输入：n，k ( 6 < n ≤ 200，2 ≤ k ≤ 6 )
输出：一个整数，即不同的分法。
```


# 矩阵输入
## 1 不同路径
62\. Unique Paths (Medium)

[力扣](https://leetcode-cn.com/problems/unique-paths/description/) / [Leetcode](https://leetcode.com/problems/unique-paths/description/) / [Cpp](../algo_05_dynamic_plan/dp_7_matrix_path/L62-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_7_matrix_path/L62-m.py) 
```
题目: 一个机器人位于一个 m x n 网格的左上角 
     机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。
     问总共有多少条不同的路径？
```

## 2 不同路径II
63\. Unique Paths II

[力扣](https://leetcode-cn.com/problems/unique-paths-ii/) / [Leetcode](https://leetcode-cn.com/problems/unique-paths-ii/) / [Cpp](../algo_05_dynamic_plan/dp_7_matrix_path/L63-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_7_matrix_path/L63-m.py) 
```
题目: 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
   机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
   现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
```

## 3 最小路径和
64\. Minimum Path Sum (Medium)

[力扣](https://leetcode-cn.com/problems/minimum-path-sum/description/) / [Leetcode](https://leetcode.com/problems/minimum-path-sum/description/) / [Cpp](../algo_05_dynamic_plan/dp_7_matrix_path/L64-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_7_matrix_path/L64-m.py) 
```
题目:给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
示例:
      输入:
      [
        [1,3,1],
        [1,5,1],
        [4,2,1]
      ]
      输出: 7
      解释: 因为路径 1→3→1→1→1 的总和最小。
```

## 4 最大正方形
221\. Maximal Square

[力扣](https://leetcode-cn.com/problems/maximal-square/) / [Leetcode](https://leetcode.com/problems/maximal-square/) / [Cpp](../algo_05_dynamic_plan/dp_8_max_matrix/L221-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_8_max_matrix/L221-m.py) 
```
题目:在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
示例:
      输入: 
      1 0 1 0 0
      1 0 1 1 1
      1 1 1 1 1
      1 0 0 1 0
      输出: 4
```


## 5 三角形最小路径和
120\. Maximal Square

[力扣](https://leetcode-cn.com/problems/triangle/) / [Leetcode](https://leetcode-cn.com/problems/triangle/) / [Cpp](../algo_05_dynamic_plan/dp_8_max_matrix/L120-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_8_max_matrix/L120-m.py) 
```
题目:给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 
相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，
那么下一步可以移动到下一行的下标 i 或 i + 1 。
示例 1：
         输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
         输出：11
         解释：如下面简图所示：
            2
           3 4
          6 5 7
         4 1 8 3
         自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

## 6 下降路径最小和
931\.  Minimum Falling Path Sum  

[力扣](https://leetcode-cn.com/problems/minimum-falling-path-sum/) / [Leetcode](https://leetcode.com/problems/minimum-falling-path-sum/) / [Cpp](../algo_05_dynamic_plan/dp_8_max_matrix/L931-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_8_max_matrix/L931-m.py) 
```
给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。
下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。
在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。
具体来说，位置 (row, col) 的下一个元素应当是 
(row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。
示例 1：
      输入：matrix = [[2,1,3],[6,5,4],[7,8,9]]
      输出：13
      解释：下面是两条和最小的下降路径，用加粗标注：
      [[2,1,3],      [[2,1,3],
       [6,5,4],       [6,5,4],
       [7,8,9]]       [7,8,9]]
```

## 7 马在棋盘上的概率
688\.  马在棋盘上的概率  

[力扣](https://leetcode-cn.com/problems/knight-probability-in-chessboard/) / [Leetcode](https://leetcode.com/problems/knight-probability-in-chessboard/) / [Cpp](../algo_05_dynamic_plan/dp_8_max_matrix/L688-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_8_max_matrix/L688-m.py) 
```
已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。
即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。 
现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 
如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，
然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。
```

## 8 最大的以1为边界的正方形
1139\.  最大的以1为边界的正方形   

[力扣](https://leetcode-cn.com/problems/largest-1-bordered-square/) / [Leetcode](https://leetcode.com/problems/largest-1-bordered-square/) / [Cpp](../algo_05_dynamic_plan/dp_8_max_matrix/L1139-m.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_8_max_matrix/L1139-m.py) 
```
给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 
正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。
示例 1：
      输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
      输出：9
```

## 9 最大矩形
85\. Maximal Rectangle (hard)

[力扣](https://leetcode-cn.com/problems/maximal-rectangle/) / [Leetcode](https://leetcode.com/problems/maximal-rectangle/) / [Cpp](../algo_05_dynamic_plan/dp_8_max_matrix/L85-h.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_8_max_matrix/L85-h.py) 
```
题目:给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
示例:
      输入:
      [
        ["1","0","1","0","0"],
        ["1","0","1","1","1"],
        ["1","1","1","1","1"],
        ["1","0","0","1","0"]
      ]
      输出: 6
```


# 股票问题
## 1 买卖股票一次交易
121\. Best Time to Buy and Sell Stock

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) / [Cpp](../algo_05_dynamic_plan/dp_9_stock/L121.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/L121.py) 
```
题目:给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
    如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
    注意：你不能在买入股票前卖出股票。
示例 1:
      输入: [7,1,5,3,6,4]
      输出: 5
      解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
           注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

## 2 买卖股票不限次数
122\. Best Time to Buy and Sell Stock II

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) / [Cpp](../algo_05_dynamic_plan/dp_9_stock/L122.cpp) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/L122.py) 
```
题目: 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
     设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
     注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）
示例 1:
      输入: [7,1,5,3,6,4]
      输出: 7
      解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
           随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

## 3 最佳买卖股票时机含冷冻期不限次数
309\. Best Time to Buy and Sell Stock with Cooldown(Medium)

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/) /  [Cpp](../algo_05_dynamic_plan/dp_9_stock/) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/) 
```
题目:给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
    设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
    你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
    卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例:
      输入: [1,2,3,0,2]
      输出: 3 
      解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

## 4 买卖股票的最佳时机含手续费不限次数
714\. Best Time to Buy and Sell Stock with Transaction Fee (Medium)

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/) / [Cpp](../algo_05_dynamic_plan/dp_9_stock/) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/) 
```
题目:给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。
    你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
    返回获得利润的最大值。
    注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
示例 1:
      输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
      输出: 8
      解释: 能够达到的最大利润:  
      在此处买入 prices[0] = 1
      在此处卖出 prices[3] = 8
      在此处买入 prices[4] = 4
      在此处卖出 prices[5] = 9
      总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

## 5 只能进行两次的股票交易
123\. Best Time to Buy and Sell Stock III (Hard)

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/description/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/) / [Cpp](../algo_05_dynamic_plan/dp_9_stock/) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/) 
```
题目:给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
    设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
    注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
      输入: [3,3,5,0,0,3,1,4]
      输出: 6
      解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
           随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2:
      输入: [1,2,3,4,5]
      输出: 4
      解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
           注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
           因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

## 6 只能进行k次的股票交易
188\. Best Time to Buy and Sell Stock IV (Hard)

[力扣](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/description/) / [Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/) / [Cpp](../algo_05_dynamic_plan/dp_9_stock/) / [Python3](../python-algorithm/algo_05_dynamic_plan/dp_9_stock/) 
```
题目:给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
     设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
注意:你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
      输入: [2,4,1], k = 2
      输出: 2
      解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
示例 2:
      输入: [3,2,6,5,0,3], k = 2
      输出: 7
      解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
           随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```
