<!-- GFM-TOC -->

* [1. 生存人数](#1-生存人数)
* [2. 将数组分成和相等的三个部分](#2-将数组分成和相等的三个部分)
* [3. 从链表中删去总和值为零的连续节点](#3-从链表中删去总和值为零的连续节点)
* [4. 找出第K大的异或坐标值](#4-找出第K大的异或坐标值)
* [5. 连续的子数组和](#5-连续的子数组和)
* [6. 和可被K整除的子数组](#6-和可被K整除的子数组)
* [7. 矩阵区域和](#7-矩阵区域和)

<!-- GFM-TOC -->


## 1 生存人数
面试题 16.10. 生存人数  

[力扣](https://leetcode-cn.com/problems/living-people-lcci/) / [Python3](../python-algorithm/algo_11_prefix_sum/16.10.py) 
```
给定 N 个人的出生年份和死亡年份，第 i 个人的出生年份为 birth[i]，死亡年份为 death[i]，实现一个方法以计算生存人数最多的年份。
你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，
那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。

如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。

输入：
         birth = {1900, 1901, 1950}
         death = {1948, 1951, 2000}
输出： 1901
```

## 2 将数组分成和相等的三个部分
1013\. Partition Array Into Three Parts With Equal Sum

[力扣](https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/) / [Python3](../python-algorithm/algo_11_prefix_sum/L1013.py) 
```
给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。

形式上，如果可以找出索引 i+1 < j 且满足 A[0] + A[1] + ... + A[i] == 
A[i+1] + A[i+2] + ... + A[j-1] == 
A[j] + A[j-1] + ... + A[A.length - 1] 就可以将数组三等分。
```

## 3 从链表中删去总和值为零的连续节点
1171\. Remove Zero Sum Consecutive Nodes from Linked List

[力扣](https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/) / [Python3](../python-algorithm/algo_11_prefix_sum/L1171-m.py) 
```
给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。
删除完毕后，请你返回最终结果链表的头节点。
```

## 4 找出第K大的异或坐标值
1738\. Find Kth Largest XOR Coordinate Value

[力扣](https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/) / [Python3](../python-algorithm/algo_11_prefix_sum/L1738-m.py) 
```
给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。
矩阵中坐标 (a, b) 的 值 可由对所有满足 0 <= i <= a < m 且 0 <= j <= b < n 的
元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。
请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。
```

## 5 连续的子数组和
523\. Continuous Subarray Sum

[力扣](https://leetcode-cn.com/problems/continuous-subarray-sum/) / [Python3](../python-algorithm/algo_11_prefix_sum/L523-m.py) 
```
给定一个包含 非负数 的数组和一个目标 整数 k ，编写一个函数来判断该数组是否含有连续的子数组，
其大小至少为 2，且总和为 k 的倍数，即总和为 n * k ，其中 n 也是一个整数。
```

## 6 和可被K整除的子数组
974\. Subarray Sums Divisible by K

[力扣](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/) / [Python3](../python-algorithm/algo_11_prefix_sum/L974-m.py) 
```
给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。
删除完毕后，请你返回最终结果链表的头节点。
```

## 7 矩阵区域和
1314\. Matrix Block Sum

[力扣](https://leetcode-cn.com/problems/matrix-block-sum/) / [Python3](../python-algorithm/algo_11_prefix_sum/L1314-m.py) 
```
给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，
其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： 

i - k <= r <= i + k,
j - k <= c <= j + k 且
(r, c) 在矩阵内。
```
