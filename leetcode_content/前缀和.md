<!-- GFM-TOC -->

* [1. 生存人数](#1-生存人数)
* [2. 将数组分成和相等的三个部分](#2-将数组分成和相等的三个部分)

<!-- GFM-TOC -->


## 1 生存人数
面试题 16.10. 生存人数  

[力扣](https://leetcode-cn.com/problems/living-people-lcci/) / [Python3](../python-algorithm/algo_11_prefix_sum/16.10.py) 
```
给定 N 个人的出生年份和死亡年份，第 i 个人的出生年份为 birth[i]，死亡年份为 death[i]，实现一个方法以计算生存人数最多的年份。
你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，
那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。

如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。

输入：
         birth = {1900, 1901, 1950}
         death = {1948, 1951, 2000}
输出： 1901
```

## 2 将数组分成和相等的三个部分
1013\. Partition Array Into Three Parts With Equal Sum

[力扣](https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/) / [Python3](../python-algorithm/algo_11_prefix_sum/L1013.py) 
```
给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。

形式上，如果可以找出索引 i+1 < j 且满足 A[0] + A[1] + ... + A[i] == 
A[i+1] + A[i+2] + ... + A[j-1] == 
A[j] + A[j-1] + ... + A[A.length - 1] 就可以将数组三等分。
```



